{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Narrative","text":"<p>A Python library that marries symbolic planning with large language models (LLMs) to create compelling narratives.</p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p>Narrative is an open-source Python library that combines symbolic planning with large language models (LLMs) to keep interactive narratives coherent, reactive, and designer-friendly.</p> <p>It transforms domain definitions into Intention Dependency Graphs (IDGs), serves up exemplar story branches in milliseconds, and hands those skeletons to an LLM to render rich prose or dialogue.</p> <p>This library is based on the research presented in this AAAI paper, which introduces the concept of Intention Dependency Graphs for narrative generation.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Domain Modeling: Define narrative domains with characters, locations, intentions, and dependencies</li> <li>Intention Dependency Graphs: Build and visualize graphs of narrative intentions and their dependencies</li> <li>Trajectory Exploration: Generate and rank possible narrative trajectories through the IDG</li> <li>LLM Rendering: Convert trajectories into natural language stories using LLMs</li> <li>Extensible Architecture: Create custom metrics, adapters, and visualizations</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install narrative\n</code></pre> <p>For more installation options, see the Installation Guide.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from narrative import Domain, IDGBuilder, TrajectoryExplorer, LLMRenderer\n\n# Define a simple domain based on Little Red Riding Hood\ndomain = Domain(\n    characters=[\"little_red\", \"wolf\", \"grandmother\", \"hunter\"],\n    locations=[\"forest\", \"cottage\", \"village\"],\n    intentions=[\n        {\"id\": \"visit_grandmother\", \"character\": \"little_red\", \"target\": \"grandmother\", \"location\": \"cottage\"},\n        {\"id\": \"deliver_basket\", \"character\": \"little_red\", \"target\": \"grandmother\", \"location\": \"cottage\"},\n        {\"id\": \"eat_little_red\", \"character\": \"wolf\", \"target\": \"little_red\", \"location\": \"forest\"},\n        {\"id\": \"eat_grandmother\", \"character\": \"wolf\", \"target\": \"grandmother\", \"location\": \"cottage\"},\n        {\"id\": \"rescue_little_red\", \"character\": \"hunter\", \"target\": \"little_red\", \"location\": \"cottage\"},\n        {\"id\": \"rescue_grandmother\", \"character\": \"hunter\", \"target\": \"grandmother\", \"location\": \"cottage\"},\n        {\"id\": \"kill_wolf\", \"character\": \"hunter\", \"target\": \"wolf\", \"location\": \"cottage\"}\n    ],\n    dependencies=[\n        {\"from_intention\": \"deliver_basket\", \"to_intention\": \"visit_grandmother\", \"type\": \"intentional\"},\n        {\"from_intention\": \"eat_little_red\", \"to_intention\": \"visit_grandmother\", \"type\": \"motivational\"},\n        {\"from_intention\": \"eat_grandmother\", \"to_intention\": \"visit_grandmother\", \"type\": \"motivational\"},\n        {\"from_intention\": \"rescue_little_red\", \"to_intention\": \"eat_little_red\", \"type\": \"motivational\"},\n        {\"from_intention\": \"rescue_grandmother\", \"to_intention\": \"eat_grandmother\", \"type\": \"motivational\"},\n        {\"from_intention\": \"kill_wolf\", \"to_intention\": \"eat_little_red\", \"type\": \"motivational\"},\n        {\"from_intention\": \"kill_wolf\", \"to_intention\": \"eat_grandmother\", \"type\": \"motivational\"}\n    ]\n)\n\n# Build IDG\nidg_builder = IDGBuilder(domain)\nidg = idg_builder.build()\n\n# Explore trajectories\nexplorer = TrajectoryExplorer(idg)\ntrajectories = explorer.get_trajectories(max_length=7)\nranked_trajectories = explorer.rank_trajectories(trajectories, metric=\"novelty\")\n\n# Render story\nrenderer = LLMRenderer()\nstory = renderer.render(ranked_trajectories[0])\n\nprint(story)\n</code></pre>"},{"location":"#why-narrative","title":"Why Narrative?","text":""},{"location":"#for-game-developers","title":"For Game Developers","text":"<ul> <li>Create coherent, branching narratives that respond to player choices</li> <li>Ensure narrative consistency while allowing for emergent storytelling</li> <li>Generate rich prose and dialogue from simple narrative structures</li> </ul>"},{"location":"#for-researchers","title":"For Researchers","text":"<ul> <li>Experiment with hybrid symbolic-neural approaches to narrative generation</li> <li>Study the interaction between planning and natural language generation</li> <li>Develop and test new metrics for narrative quality</li> </ul>"},{"location":"#for-writers","title":"For Writers","text":"<ul> <li>Explore alternative narrative paths and \"what if\" scenarios</li> <li>Generate story outlines and drafts based on character intentions</li> <li>Experiment with different narrative structures and dependencies</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide: How to install Narrative</li> <li>Quick Start Guide: Create your first narrative</li> <li>Core Concepts: Learn about the key concepts behind Narrative</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! See the Contributing Guide for more information.</p>"},{"location":"#license","title":"License","text":"<p>Narrative is licensed under the MIT License. See the LICENSE file for more information.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use Narrative in your research, please cite it as:</p> <pre><code>@software{narrative2025,\n  author = {Narrative Contributors},\n  title = {Narrative: A Python library for narrative generation},\n  year = {2025},\n  url = {https://github.com/org/narrative},\n}\n</code></pre> <p>Please also cite the original research paper that this library is based on:</p> <pre><code>@inproceedings{idg2020,\n  title = {Intention Dependency Graphs for Interactive Narrative Generation},\n  author = {Paper Authors},\n  booktitle = {Proceedings of the AAAI Conference on Artificial Intelligence},\n  year = {2020},\n  url = {https://cdn.aaai.org/ojs/12989/12989-52-16506-1-2-20201228.pdf}\n}\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>First release of Narrative</li> <li>Core functionality for narrative generation</li> <li>Integration with LLMs for story rendering</li> <li>Example implementations</li> <li>Documentation</li> </ul>"},{"location":"changelog/#v020-2025-05-18","title":"v0.2.0 (2025-05-18)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>NOTICKET: spike of initial narrative functioanlity</li> </ul>"},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>NOTICKET: fix errors and warnings with Pydantic</li> <li>NOTICKET: update upload artiact to v4</li> <li>NOTICKET: fix autodocs errors</li> </ul>"},{"location":"contributing/","title":"Contributing to Narrative","text":"<p>Thank you for your interest in contributing to Narrative! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, you agree to abide by our Code of Conduct. Please be respectful and considerate of others when participating in discussions, submitting issues, or contributing code.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>Poetry (for dependency management)</li> <li>Git</li> </ul>"},{"location":"contributing/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally:    <pre><code>git clone https://github.com/your-username/narrative.git\ncd narrative\n</code></pre></li> <li>Install dependencies using Poetry:    <pre><code>poetry install\n</code></pre></li> <li>Set up pre-commit hooks:    <pre><code>poetry run pre-commit install\n</code></pre></li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#creating-a-branch","title":"Creating a Branch","text":"<p>Create a new branch for your changes:</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <p>Use a descriptive branch name that reflects the changes you're making.</p>"},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Make your changes to the codebase</li> <li>Add tests for your changes</li> <li>Run the tests to ensure they pass:    <pre><code>poetry run pytest\n</code></pre></li> <li>Update documentation as needed</li> </ol>"},{"location":"contributing/#committing-changes","title":"Committing Changes","text":"<p>We follow the Conventional Commits specification for commit messages. This helps us generate changelogs and versioning automatically.</p> <p>Format your commit messages as follows:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>Types include: - <code>feat</code>: A new feature - <code>fix</code>: A bug fix - <code>docs</code>: Documentation changes - <code>style</code>: Changes that do not affect the meaning of the code (formatting, etc.) - <code>refactor</code>: Code changes that neither fix a bug nor add a feature - <code>perf</code>: Performance improvements - <code>test</code>: Adding or correcting tests - <code>chore</code>: Changes to the build process or auxiliary tools</p> <p>Example: <pre><code>feat(idg): add support for custom intention types\n\nThis commit adds support for custom intention types in the IDG builder.\nThe Domain class now accepts a custom_intention_types parameter.\n\nCloses #123\n</code></pre></p>"},{"location":"contributing/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ol> <li>Push your changes to your fork:    <pre><code>git push origin feature/your-feature-name\n</code></pre></li> <li>Go to the original repository on GitHub and create a pull request</li> <li>Fill out the pull request template with details about your changes</li> <li>Wait for a maintainer to review your pull request</li> </ol>"},{"location":"contributing/#testing","title":"Testing","text":"<p>We use pytest for testing. All new code should include appropriate tests.</p> <p>Run the tests with:</p> <pre><code>poetry run pytest\n</code></pre> <p>For coverage reports:</p> <pre><code>poetry run pytest --cov=narrative\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>We use MkDocs with the Material theme for documentation. Documentation is written in Markdown and stored in the <code>docs/</code> directory.</p>"},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"<p>Build the documentation with:</p> <pre><code>poetry run mkdocs build\n</code></pre> <p>Serve the documentation locally with:</p> <pre><code>poetry run mkdocs serve\n</code></pre> <p>Then visit <code>http://localhost:8000</code> to view the documentation.</p>"},{"location":"contributing/#api-documentation","title":"API Documentation","text":"<p>API documentation is generated automatically from docstrings using mkdocstrings. Please follow the Google docstring style for all functions and classes:</p> <pre><code>def example_function(param1, param2):\n    \"\"\"Short description of the function.\n\n    Longer description explaining the function in more detail.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of the return value\n\n    Raises:\n        ExceptionType: When and why this exception is raised\n    \"\"\"\n    # Function implementation\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We follow the Black code style and use isort for import sorting. These are enforced by pre-commit hooks.</p> <p>Additionally, we use flake8 for linting and mypy for type checking.</p> <p>Run the style checks with:</p> <pre><code>poetry run pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#release-process","title":"Release Process","text":"<p>Releases are managed by the maintainers. We follow semantic versioning (SemVer) for version numbers.</p>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<p>If you need help with contributing, please:</p> <ol> <li>Check the documentation</li> <li>Look for similar issues on the issue tracker</li> <li>Open a new issue with your question</li> </ol>"},{"location":"contributing/#thank-you","title":"Thank You","text":"<p>Your contributions are greatly appreciated! By contributing to Narrative, you're helping to make it a better tool for everyone.</p>"},{"location":"api/idg-engine/","title":"Idg Builder","text":"<p>IDG Builder</p> <p>This module contains the IDGBuilder class, which builds an Intention Dependency Graph (IDG) from a domain.</p>"},{"location":"api/idg-engine/#narrative.core.idg_builder.IDG","title":"<code>IDG</code>","text":"<p>             Bases: <code>DiGraph</code></p> <p>Intention Dependency Graph (IDG) class.</p> <p>An IDG is a directed graph where nodes represent intentions and edges represent dependencies between intentions. This class extends networkx.DiGraph to provide additional methods for working with IDGs.</p> Source code in <code>narrative/core/idg_builder.py</code> <pre><code>class IDG(nx.DiGraph):\n    \"\"\"\n    Intention Dependency Graph (IDG) class.\n\n    An IDG is a directed graph where nodes represent intentions and edges\n    represent dependencies between intentions. This class extends\n    networkx.DiGraph to provide additional methods for working with IDGs.\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize an IDG.\"\"\"\n        super().__init__(*args, **kwargs)\n\n    def get_root_intentions(self) -&gt; Set[str]:\n        \"\"\"\n        Get the root intentions in the IDG.\n\n        Root intentions are intentions that are not depended upon by any other\n        intention.\n\n        Returns:\n            A set of intention IDs that are roots in the IDG.\n        \"\"\"\n        return {node for node in self.nodes if self.in_degree(node) == 0}\n\n    def get_leaf_intentions(self) -&gt; Set[str]:\n        \"\"\"\n        Get the leaf intentions in the IDG.\n\n        Leaf intentions are intentions that do not depend on any other\n        intention.\n\n        Returns:\n            A set of intention IDs that are leaves in the IDG.\n        \"\"\"\n        return {node for node in self.nodes if self.out_degree(node) == 0}\n\n    def get_intention_data(self, intention_id: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get the data associated with an intention.\n\n        Args:\n            intention_id: The ID of the intention.\n\n        Returns:\n            A dictionary containing the intention data.\n\n        Raises:\n            KeyError: If the intention ID is not in the IDG.\n        \"\"\"\n        return dict(self.nodes[intention_id])\n\n    def get_dependency_data(\n        self, from_intention: str, to_intention: str\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get the data associated with a dependency.\n\n        Args:\n            from_intention: The ID of the intention that depends on another.\n            to_intention: The ID of the intention that is depended upon.\n\n        Returns:\n            A dictionary containing the dependency data.\n\n        Raises:\n            KeyError: If the dependency is not in the IDG.\n        \"\"\"\n        return dict(self.edges[from_intention, to_intention])\n\n    def visualize(\n        self,\n        figsize: Tuple[int, int] = (12, 8),\n        node_size: int = 2000,\n        font_size: int = 10,\n        edge_width: int = 2,\n        edge_color: str = \"black\",\n        node_color: str = \"lightblue\",\n        with_labels: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Visualize the IDG using matplotlib.\n\n        Args:\n            figsize: The figure size (width, height) in inches.\n            node_size: The size of the nodes.\n            font_size: The font size for the node labels.\n            edge_width: The width of the edges.\n            edge_color: The color of the edges.\n            node_color: The color of the nodes.\n            with_labels: Whether to display node labels.\n\n        Raises:\n            ImportError: If matplotlib is not installed.\n        \"\"\"\n        try:\n            import matplotlib.pyplot as plt\n        except ImportError as err:\n            raise ImportError(\n                \"Matplotlib is required for visualization. \"\n                \"Install it with 'pip install matplotlib'.\"\n            ) from err\n\n        plt.figure(figsize=figsize)\n        pos = nx.spring_layout(self, seed=42)\n        nx.draw(\n            self,\n            pos,\n            with_labels=with_labels,\n            node_size=node_size,\n            font_size=font_size,\n            width=edge_width,\n            edge_color=edge_color,\n            node_color=node_color,\n        )\n\n        # Add edge labels for dependency types\n        edge_labels = {(u, v): self.edges[u, v][\"type\"] for u, v in self.edges}\n        nx.draw_networkx_edge_labels(self, pos, edge_labels=edge_labels)\n\n        plt.axis(\"off\")\n        plt.tight_layout()\n        plt.show()\n</code></pre>"},{"location":"api/idg-engine/#narrative.core.idg_builder.IDG.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize an IDG.</p> Source code in <code>narrative/core/idg_builder.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize an IDG.\"\"\"\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"api/idg-engine/#narrative.core.idg_builder.IDG.get_dependency_data","title":"<code>get_dependency_data(from_intention, to_intention)</code>","text":"<p>Get the data associated with a dependency.</p> <p>Parameters:</p> Name Type Description Default <code>from_intention</code> <code>str</code> <p>The ID of the intention that depends on another.</p> required <code>to_intention</code> <code>str</code> <p>The ID of the intention that is depended upon.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary containing the dependency data.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the dependency is not in the IDG.</p> Source code in <code>narrative/core/idg_builder.py</code> <pre><code>def get_dependency_data(\n    self, from_intention: str, to_intention: str\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the data associated with a dependency.\n\n    Args:\n        from_intention: The ID of the intention that depends on another.\n        to_intention: The ID of the intention that is depended upon.\n\n    Returns:\n        A dictionary containing the dependency data.\n\n    Raises:\n        KeyError: If the dependency is not in the IDG.\n    \"\"\"\n    return dict(self.edges[from_intention, to_intention])\n</code></pre>"},{"location":"api/idg-engine/#narrative.core.idg_builder.IDG.get_intention_data","title":"<code>get_intention_data(intention_id)</code>","text":"<p>Get the data associated with an intention.</p> <p>Parameters:</p> Name Type Description Default <code>intention_id</code> <code>str</code> <p>The ID of the intention.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary containing the intention data.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the intention ID is not in the IDG.</p> Source code in <code>narrative/core/idg_builder.py</code> <pre><code>def get_intention_data(self, intention_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the data associated with an intention.\n\n    Args:\n        intention_id: The ID of the intention.\n\n    Returns:\n        A dictionary containing the intention data.\n\n    Raises:\n        KeyError: If the intention ID is not in the IDG.\n    \"\"\"\n    return dict(self.nodes[intention_id])\n</code></pre>"},{"location":"api/idg-engine/#narrative.core.idg_builder.IDG.get_leaf_intentions","title":"<code>get_leaf_intentions()</code>","text":"<p>Get the leaf intentions in the IDG.</p> <p>Leaf intentions are intentions that do not depend on any other intention.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>A set of intention IDs that are leaves in the IDG.</p> Source code in <code>narrative/core/idg_builder.py</code> <pre><code>def get_leaf_intentions(self) -&gt; Set[str]:\n    \"\"\"\n    Get the leaf intentions in the IDG.\n\n    Leaf intentions are intentions that do not depend on any other\n    intention.\n\n    Returns:\n        A set of intention IDs that are leaves in the IDG.\n    \"\"\"\n    return {node for node in self.nodes if self.out_degree(node) == 0}\n</code></pre>"},{"location":"api/idg-engine/#narrative.core.idg_builder.IDG.get_root_intentions","title":"<code>get_root_intentions()</code>","text":"<p>Get the root intentions in the IDG.</p> <p>Root intentions are intentions that are not depended upon by any other intention.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>A set of intention IDs that are roots in the IDG.</p> Source code in <code>narrative/core/idg_builder.py</code> <pre><code>def get_root_intentions(self) -&gt; Set[str]:\n    \"\"\"\n    Get the root intentions in the IDG.\n\n    Root intentions are intentions that are not depended upon by any other\n    intention.\n\n    Returns:\n        A set of intention IDs that are roots in the IDG.\n    \"\"\"\n    return {node for node in self.nodes if self.in_degree(node) == 0}\n</code></pre>"},{"location":"api/idg-engine/#narrative.core.idg_builder.IDG.visualize","title":"<code>visualize(figsize=(12, 8), node_size=2000, font_size=10, edge_width=2, edge_color='black', node_color='lightblue', with_labels=True)</code>","text":"<p>Visualize the IDG using matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>figsize</code> <code>Tuple[int, int]</code> <p>The figure size (width, height) in inches.</p> <code>(12, 8)</code> <code>node_size</code> <code>int</code> <p>The size of the nodes.</p> <code>2000</code> <code>font_size</code> <code>int</code> <p>The font size for the node labels.</p> <code>10</code> <code>edge_width</code> <code>int</code> <p>The width of the edges.</p> <code>2</code> <code>edge_color</code> <code>str</code> <p>The color of the edges.</p> <code>'black'</code> <code>node_color</code> <code>str</code> <p>The color of the nodes.</p> <code>'lightblue'</code> <code>with_labels</code> <code>bool</code> <p>Whether to display node labels.</p> <code>True</code> <p>Raises:</p> Type Description <code>ImportError</code> <p>If matplotlib is not installed.</p> Source code in <code>narrative/core/idg_builder.py</code> <pre><code>def visualize(\n    self,\n    figsize: Tuple[int, int] = (12, 8),\n    node_size: int = 2000,\n    font_size: int = 10,\n    edge_width: int = 2,\n    edge_color: str = \"black\",\n    node_color: str = \"lightblue\",\n    with_labels: bool = True,\n) -&gt; None:\n    \"\"\"\n    Visualize the IDG using matplotlib.\n\n    Args:\n        figsize: The figure size (width, height) in inches.\n        node_size: The size of the nodes.\n        font_size: The font size for the node labels.\n        edge_width: The width of the edges.\n        edge_color: The color of the edges.\n        node_color: The color of the nodes.\n        with_labels: Whether to display node labels.\n\n    Raises:\n        ImportError: If matplotlib is not installed.\n    \"\"\"\n    try:\n        import matplotlib.pyplot as plt\n    except ImportError as err:\n        raise ImportError(\n            \"Matplotlib is required for visualization. \"\n            \"Install it with 'pip install matplotlib'.\"\n        ) from err\n\n    plt.figure(figsize=figsize)\n    pos = nx.spring_layout(self, seed=42)\n    nx.draw(\n        self,\n        pos,\n        with_labels=with_labels,\n        node_size=node_size,\n        font_size=font_size,\n        width=edge_width,\n        edge_color=edge_color,\n        node_color=node_color,\n    )\n\n    # Add edge labels for dependency types\n    edge_labels = {(u, v): self.edges[u, v][\"type\"] for u, v in self.edges}\n    nx.draw_networkx_edge_labels(self, pos, edge_labels=edge_labels)\n\n    plt.axis(\"off\")\n    plt.tight_layout()\n    plt.show()\n</code></pre>"},{"location":"api/idg-engine/#narrative.core.idg_builder.IDGBuilder","title":"<code>IDGBuilder</code>","text":"<p>Builder class for creating Intention Dependency Graphs (IDGs) from domains.</p> Source code in <code>narrative/core/idg_builder.py</code> <pre><code>class IDGBuilder:\n    \"\"\"\n    Builder class for creating Intention Dependency Graphs (IDGs) from domains.\n    \"\"\"\n\n    def __init__(self, domain: Domain):\n        \"\"\"\n        Initialize an IDGBuilder with a domain.\n\n        Args:\n            domain: The domain to build an IDG from.\n        \"\"\"\n        self.domain = domain\n\n    def build(self) -&gt; IDG:\n        \"\"\"\n        Build an IDG from the domain.\n\n        Returns:\n            An IDG representing the domain.\n        \"\"\"\n        idg = IDG()\n\n        # Add nodes (intentions)\n        for intention_obj in self.domain.intentions:\n            # Convert to Intention if it's a dict\n            if isinstance(intention_obj, dict):\n                intention = Intention(**intention_obj)\n            else:\n                intention = intention_obj\n\n            # Create node attributes\n            node_attrs = {\n                \"character\": intention.character,\n                \"target\": intention.target,\n                \"location\": intention.location,\n                \"description\": intention.description,\n                \"metadata\": intention.metadata,\n            }\n\n            # Add node with intention data\n            idg.add_node(intention.id, **node_attrs)\n\n        # Add edges (dependencies)\n        for dependency_obj in self.domain.dependencies:\n            # Convert to Dependency if it's a dict\n            if isinstance(dependency_obj, dict):\n                dependency = Dependency(**dependency_obj)\n            else:\n                dependency = dependency_obj\n\n            # Create edge attributes\n            edge_attrs = {\n                \"type\": dependency.type,\n                \"description\": dependency.description,\n                \"metadata\": dependency.metadata,\n            }\n\n            # Add edge with dependency data\n            idg.add_edge(\n                dependency.from_intention, dependency.to_intention, **edge_attrs\n            )\n\n        return idg\n\n    def validate(self) -&gt; List[str]:\n        \"\"\"\n        Validate the domain.\n\n        This method checks that all characters, locations, and intentions\n        referenced in the domain\n        actually exist.\n\n        Returns:\n            A list of validation error messages. If the list is empty,\n            the domain is valid.\n        \"\"\"\n        errors: List[str] = []\n\n        # Check that all characters referenced in intentions exist\n        for intention_obj in self.domain.intentions:\n            # Convert to Intention if it's a dict\n            if isinstance(intention_obj, dict):\n                intention = Intention(**intention_obj)\n            else:\n                intention = intention_obj\n\n            if intention.character not in self.domain.characters:\n                errors.append(\n                    f\"Character '{intention.character}' missing (id: {intention.id}).\"\n                )\n\n            if intention.target not in self.domain.characters:\n                errors.append(\n                    f\"Target '{intention.target}' missing (id: {intention.id}).\"\n                )\n\n        # Check that all locations referenced in intentions exist\n        for intention_obj in self.domain.intentions:\n            # Convert to Intention if it's a dict\n            if isinstance(intention_obj, dict):\n                intention = Intention(**intention_obj)\n            else:\n                intention = intention_obj\n\n            if intention.location not in self.domain.locations:\n                errors.append(\n                    f\"Location '{intention.location}' missing (id: {intention.id}).\"\n                )\n\n        # Check that all intentions referenced in dependencies exist\n        intention_ids = set()\n        for intention_obj in self.domain.intentions:\n            if isinstance(intention_obj, dict):\n                intention_ids.add(intention_obj[\"id\"])\n            else:\n                intention_ids.add(intention_obj.id)\n\n        for dependency_obj in self.domain.dependencies:\n            # Convert to Dependency if it's a dict\n            if isinstance(dependency_obj, dict):\n                dependency = Dependency(**dependency_obj)\n            else:\n                dependency = dependency_obj\n\n            if dependency.from_intention not in intention_ids:\n                errors.append(f\"From-intention '{dependency.from_intention}' missing.\")\n\n            if dependency.to_intention not in intention_ids:\n                errors.append(f\"To-intention '{dependency.to_intention}' missing.\")\n\n        return errors\n</code></pre>"},{"location":"api/idg-engine/#narrative.core.idg_builder.IDGBuilder.__init__","title":"<code>__init__(domain)</code>","text":"<p>Initialize an IDGBuilder with a domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain to build an IDG from.</p> required Source code in <code>narrative/core/idg_builder.py</code> <pre><code>def __init__(self, domain: Domain):\n    \"\"\"\n    Initialize an IDGBuilder with a domain.\n\n    Args:\n        domain: The domain to build an IDG from.\n    \"\"\"\n    self.domain = domain\n</code></pre>"},{"location":"api/idg-engine/#narrative.core.idg_builder.IDGBuilder.build","title":"<code>build()</code>","text":"<p>Build an IDG from the domain.</p> <p>Returns:</p> Type Description <code>IDG</code> <p>An IDG representing the domain.</p> Source code in <code>narrative/core/idg_builder.py</code> <pre><code>def build(self) -&gt; IDG:\n    \"\"\"\n    Build an IDG from the domain.\n\n    Returns:\n        An IDG representing the domain.\n    \"\"\"\n    idg = IDG()\n\n    # Add nodes (intentions)\n    for intention_obj in self.domain.intentions:\n        # Convert to Intention if it's a dict\n        if isinstance(intention_obj, dict):\n            intention = Intention(**intention_obj)\n        else:\n            intention = intention_obj\n\n        # Create node attributes\n        node_attrs = {\n            \"character\": intention.character,\n            \"target\": intention.target,\n            \"location\": intention.location,\n            \"description\": intention.description,\n            \"metadata\": intention.metadata,\n        }\n\n        # Add node with intention data\n        idg.add_node(intention.id, **node_attrs)\n\n    # Add edges (dependencies)\n    for dependency_obj in self.domain.dependencies:\n        # Convert to Dependency if it's a dict\n        if isinstance(dependency_obj, dict):\n            dependency = Dependency(**dependency_obj)\n        else:\n            dependency = dependency_obj\n\n        # Create edge attributes\n        edge_attrs = {\n            \"type\": dependency.type,\n            \"description\": dependency.description,\n            \"metadata\": dependency.metadata,\n        }\n\n        # Add edge with dependency data\n        idg.add_edge(\n            dependency.from_intention, dependency.to_intention, **edge_attrs\n        )\n\n    return idg\n</code></pre>"},{"location":"api/idg-engine/#narrative.core.idg_builder.IDGBuilder.validate","title":"<code>validate()</code>","text":"<p>Validate the domain.</p> <p>This method checks that all characters, locations, and intentions referenced in the domain actually exist.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of validation error messages. If the list is empty,</p> <code>List[str]</code> <p>the domain is valid.</p> Source code in <code>narrative/core/idg_builder.py</code> <pre><code>def validate(self) -&gt; List[str]:\n    \"\"\"\n    Validate the domain.\n\n    This method checks that all characters, locations, and intentions\n    referenced in the domain\n    actually exist.\n\n    Returns:\n        A list of validation error messages. If the list is empty,\n        the domain is valid.\n    \"\"\"\n    errors: List[str] = []\n\n    # Check that all characters referenced in intentions exist\n    for intention_obj in self.domain.intentions:\n        # Convert to Intention if it's a dict\n        if isinstance(intention_obj, dict):\n            intention = Intention(**intention_obj)\n        else:\n            intention = intention_obj\n\n        if intention.character not in self.domain.characters:\n            errors.append(\n                f\"Character '{intention.character}' missing (id: {intention.id}).\"\n            )\n\n        if intention.target not in self.domain.characters:\n            errors.append(\n                f\"Target '{intention.target}' missing (id: {intention.id}).\"\n            )\n\n    # Check that all locations referenced in intentions exist\n    for intention_obj in self.domain.intentions:\n        # Convert to Intention if it's a dict\n        if isinstance(intention_obj, dict):\n            intention = Intention(**intention_obj)\n        else:\n            intention = intention_obj\n\n        if intention.location not in self.domain.locations:\n            errors.append(\n                f\"Location '{intention.location}' missing (id: {intention.id}).\"\n            )\n\n    # Check that all intentions referenced in dependencies exist\n    intention_ids = set()\n    for intention_obj in self.domain.intentions:\n        if isinstance(intention_obj, dict):\n            intention_ids.add(intention_obj[\"id\"])\n        else:\n            intention_ids.add(intention_obj.id)\n\n    for dependency_obj in self.domain.dependencies:\n        # Convert to Dependency if it's a dict\n        if isinstance(dependency_obj, dict):\n            dependency = Dependency(**dependency_obj)\n        else:\n            dependency = dependency_obj\n\n        if dependency.from_intention not in intention_ids:\n            errors.append(f\"From-intention '{dependency.from_intention}' missing.\")\n\n        if dependency.to_intention not in intention_ids:\n            errors.append(f\"To-intention '{dependency.to_intention}' missing.\")\n\n    return errors\n</code></pre>"},{"location":"api/llm-bridge/","title":"Llm Renderer","text":"<p>LLM Renderer</p> <p>This module contains the LLMRenderer class, which renders trajectories into natural language stories using large language models (LLMs).</p>"},{"location":"api/llm-bridge/#narrative.llm.llm_renderer.LLMAdapter","title":"<code>LLMAdapter</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract base class for LLM adapters.</p> <p>An LLM adapter is responsible for communicating with a specific LLM API or service.</p> Source code in <code>narrative/llm/llm_renderer.py</code> <pre><code>class LLMAdapter(ABC):\n    \"\"\"\n    Abstract base class for LLM adapters.\n\n    An LLM adapter is responsible for communicating with a\n    specific LLM API or service.\n    \"\"\"\n\n    @abstractmethod\n    def generate(self, prompt: str) -&gt; str:\n        \"\"\"\n        Generate text from a prompt using an LLM.\n\n        Args:\n            prompt: The prompt to send to the LLM.\n\n        Returns:\n            The generated text.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/llm-bridge/#narrative.llm.llm_renderer.LLMAdapter.generate","title":"<code>generate(prompt)</code>  <code>abstractmethod</code>","text":"<p>Generate text from a prompt using an LLM.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt to send to the LLM.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated text.</p> Source code in <code>narrative/llm/llm_renderer.py</code> <pre><code>@abstractmethod\ndef generate(self, prompt: str) -&gt; str:\n    \"\"\"\n    Generate text from a prompt using an LLM.\n\n    Args:\n        prompt: The prompt to send to the LLM.\n\n    Returns:\n        The generated text.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/llm-bridge/#narrative.llm.llm_renderer.LLMRenderer","title":"<code>LLMRenderer</code>","text":"<p>Renderer class for converting trajectories into natural language stories using LLMs.</p> Source code in <code>narrative/llm/llm_renderer.py</code> <pre><code>class LLMRenderer:\n    \"\"\"\n    Renderer class for converting trajectories into natural language stories\n    using LLMs.\n    \"\"\"\n\n    def __init__(self, adapter: Optional[LLMAdapter] = None):\n        \"\"\"\n        Initialize an LLMRenderer.\n\n        Args:\n            adapter: The LLM adapter to use. If not provided, a MockLLMAdapter\n                will be used.\n        \"\"\"\n        self.adapter = adapter or MockLLMAdapter()\n\n    def render(self, trajectory: Trajectory) -&gt; str:\n        \"\"\"\n        Render a trajectory into a natural language story.\n\n        Args:\n            trajectory: The trajectory to render.\n\n        Returns:\n            A natural language story.\n        \"\"\"\n        prompt = self._create_prompt(trajectory)\n        response = self.adapter.generate(prompt)\n        return self._process_response(response)\n\n    def _create_prompt(self, trajectory: Trajectory) -&gt; str:\n        \"\"\"\n        Create a prompt for the LLM from a trajectory.\n\n        Args:\n            trajectory: The trajectory to create a prompt from.\n\n        Returns:\n            A prompt for the LLM.\n        \"\"\"\n        prompt = (\n            \"Create a coherent and engaging story based on the following \"\n            \"sequence of intentions:\\n\\n\"\n        )\n\n        for i, intention in enumerate(trajectory.intentions):\n            prompt += (\n                f\"{i+1}. {intention['character']} intends to {intention['id']} \"\n                f\"{intention['target']} at {intention['location']}\"\n            )\n\n            if intention.get(\"description\"):\n                prompt += f\" {intention['description']}\"\n\n            prompt += \"\\n\"\n\n        prompt += (\n            \"\\nThe story should follow this sequence of intentions, but feel free \"\n            \"to add details, dialogue, and descriptions to make it engaging. \"\n            \"The story should be coherent and flow naturally from one intention \"\n            \"to the next.\"\n        )\n\n        return prompt\n\n    def _process_response(self, response: str) -&gt; str:\n        \"\"\"\n        Process the response from the LLM.\n\n        Args:\n            response: The response from the LLM.\n\n        Returns:\n            The processed response.\n        \"\"\"\n        # For now, just return the response as is\n        # We know response is already a string, so this is safe\n        processed_response: str = response\n        return processed_response\n</code></pre>"},{"location":"api/llm-bridge/#narrative.llm.llm_renderer.LLMRenderer.__init__","title":"<code>__init__(adapter=None)</code>","text":"<p>Initialize an LLMRenderer.</p> <p>Parameters:</p> Name Type Description Default <code>adapter</code> <code>Optional[LLMAdapter]</code> <p>The LLM adapter to use. If not provided, a MockLLMAdapter will be used.</p> <code>None</code> Source code in <code>narrative/llm/llm_renderer.py</code> <pre><code>def __init__(self, adapter: Optional[LLMAdapter] = None):\n    \"\"\"\n    Initialize an LLMRenderer.\n\n    Args:\n        adapter: The LLM adapter to use. If not provided, a MockLLMAdapter\n            will be used.\n    \"\"\"\n    self.adapter = adapter or MockLLMAdapter()\n</code></pre>"},{"location":"api/llm-bridge/#narrative.llm.llm_renderer.LLMRenderer.render","title":"<code>render(trajectory)</code>","text":"<p>Render a trajectory into a natural language story.</p> <p>Parameters:</p> Name Type Description Default <code>trajectory</code> <code>Trajectory</code> <p>The trajectory to render.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A natural language story.</p> Source code in <code>narrative/llm/llm_renderer.py</code> <pre><code>def render(self, trajectory: Trajectory) -&gt; str:\n    \"\"\"\n    Render a trajectory into a natural language story.\n\n    Args:\n        trajectory: The trajectory to render.\n\n    Returns:\n        A natural language story.\n    \"\"\"\n    prompt = self._create_prompt(trajectory)\n    response = self.adapter.generate(prompt)\n    return self._process_response(response)\n</code></pre>"},{"location":"api/llm-bridge/#narrative.llm.llm_renderer.MockLLMAdapter","title":"<code>MockLLMAdapter</code>","text":"<p>             Bases: <code>LLMAdapter</code></p> <p>A mock LLM adapter that returns a predefined response.</p> <p>This adapter is useful for testing and development when you don't want to make actual API calls to an LLM service.</p> Source code in <code>narrative/llm/llm_renderer.py</code> <pre><code>class MockLLMAdapter(LLMAdapter):\n    \"\"\"\n    A mock LLM adapter that returns a predefined response.\n\n    This adapter is useful for testing and development when you don't want to\n    make actual API calls to an LLM service.\n    \"\"\"\n\n    def generate(self, prompt: str) -&gt; str:\n        \"\"\"\n        Generate text from a prompt using a mock LLM.\n\n        Args:\n            prompt: The prompt to send to the mock LLM.\n\n        Returns:\n            A predefined response.\n        \"\"\"\n        return \"\"\"\nOnce upon a time, there was a little girl named Little Red Riding Hood. She was called that because she always wore a red hooded cloak that her grandmother had made for her.\n\nOne day, Little Red Riding Hood's mother asked her to take a basket of food to her grandmother, who lived in a cottage in the forest. The grandmother had been feeling ill, and the food would help her feel better.\n\n\"Remember, go straight to Grandmother's house,\" her mother warned. \"Don't talk to strangers and don't wander off the path.\"\n\nLittle Red Riding Hood promised to be careful and set off into the forest. As she walked along the path, she met a wolf. The wolf was cunning and wicked, and when he saw the little girl, he immediately began to think about how he could catch and eat her.\n\n\"Good day, Little Red Riding Hood,\" said the wolf, trying to sound friendly.\n\n\"Good day, Mr. Wolf,\" she replied, not knowing that he was dangerous.\n\n\"Where are you going on this fine morning?\" asked the wolf.\n\n\"I'm going to visit my grandmother. She's ill, and I'm taking her some food,\" Little Red Riding Hood answered.\n\nThe wolf thought quickly. \"Where does your grandmother live?\" he asked.\n\n\"In a cottage in the forest, just beyond the old oak tree,\" said Little Red Riding Hood, pointing down the path.\n\nThe wolf smiled wickedly. \"I hope your grandmother feels better soon,\" he said, and then he hurried away.\n\nThe wolf ran ahead to the grandmother's cottage and knocked on the door.\n\n\"Who is it?\" called the grandmother from inside.\n\n\"It's Little Red Riding Hood,\" the wolf said, disguising his voice. \"I've brought you some food.\"\n\nThe grandmother, who was in bed, called out, \"Pull the string, and the latch will open.\"\n\nThe wolf pulled the string, opened the door, and without saying another word, he swallowed the grandmother whole. Then he put on her nightcap and nightgown and got into her bed, pulling the covers up to his nose.\n\nSoon, Little Red Riding Hood arrived at the cottage and knocked on the door.\n\n\"Who is it?\" called the wolf, trying to sound like the grandmother.\n\n\"It's Little Red Riding Hood. I've brought you some food,\" she replied.\n\n\"Pull the string, and the latch will open,\" said the wolf.\n\nLittle Red Riding Hood pulled the string, opened the door, and went inside. She was surprised to see how different her grandmother looked.\n\n\"Grandmother, what big eyes you have!\" she exclaimed.\n\n\"All the better to see you with, my dear,\" replied the wolf.\n\n\"Grandmother, what big ears you have!\"\n\n\"All the better to hear you with, my dear.\"\n\n\"Grandmother, what big teeth you have!\"\n\n\"All the better to eat you with!\" growled the wolf, and he leaped out of bed and swallowed Little Red Riding Hood whole, just as he had done with her grandmother.\n\nFeeling satisfied, the wolf climbed back into bed and fell asleep, snoring loudly.\n\nA hunter who was passing by the cottage heard the loud snoring and thought it strange that the old woman would snore so loudly. He decided to check if everything was alright.\n\nWhen the hunter entered the cottage, he saw the wolf lying in the bed, still wearing the grandmother's nightcap.\n\n\"So I've found you at last, you old sinner!\" said the hunter. \"I've been looking for you for a long time!\"\n\nThe hunter was about to shoot the wolf when he thought that the wolf might have eaten the grandmother. Instead of shooting, he took a pair of scissors and cut open the wolf's belly.\n\nTo his surprise, out jumped Little Red Riding Hood and her grandmother, both alive and well.\n\n\"Thank you, kind hunter,\" they said gratefully.\n\nLittle Red Riding Hood quickly gathered some heavy stones, and they filled the wolf's belly with them while he was still asleep. When the wolf woke up, he tried to run away, but the stones were so heavy that he collapsed and died.\n\nThe hunter took the wolf's pelt, the grandmother enjoyed the food that Little Red Riding Hood had brought, and Little Red Riding Hood promised herself never to talk to strangers in the forest again.\n\nAnd they all lived happily ever after.\n\"\"\"\n</code></pre>"},{"location":"api/llm-bridge/#narrative.llm.llm_renderer.MockLLMAdapter.generate","title":"<code>generate(prompt)</code>","text":"<p>Generate text from a prompt using a mock LLM.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt to send to the mock LLM.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A predefined response.</p> Source code in <code>narrative/llm/llm_renderer.py</code> <pre><code>    def generate(self, prompt: str) -&gt; str:\n        \"\"\"\n        Generate text from a prompt using a mock LLM.\n\n        Args:\n            prompt: The prompt to send to the mock LLM.\n\n        Returns:\n            A predefined response.\n        \"\"\"\n        return \"\"\"\nOnce upon a time, there was a little girl named Little Red Riding Hood. She was called that because she always wore a red hooded cloak that her grandmother had made for her.\n\nOne day, Little Red Riding Hood's mother asked her to take a basket of food to her grandmother, who lived in a cottage in the forest. The grandmother had been feeling ill, and the food would help her feel better.\n\n\"Remember, go straight to Grandmother's house,\" her mother warned. \"Don't talk to strangers and don't wander off the path.\"\n\nLittle Red Riding Hood promised to be careful and set off into the forest. As she walked along the path, she met a wolf. The wolf was cunning and wicked, and when he saw the little girl, he immediately began to think about how he could catch and eat her.\n\n\"Good day, Little Red Riding Hood,\" said the wolf, trying to sound friendly.\n\n\"Good day, Mr. Wolf,\" she replied, not knowing that he was dangerous.\n\n\"Where are you going on this fine morning?\" asked the wolf.\n\n\"I'm going to visit my grandmother. She's ill, and I'm taking her some food,\" Little Red Riding Hood answered.\n\nThe wolf thought quickly. \"Where does your grandmother live?\" he asked.\n\n\"In a cottage in the forest, just beyond the old oak tree,\" said Little Red Riding Hood, pointing down the path.\n\nThe wolf smiled wickedly. \"I hope your grandmother feels better soon,\" he said, and then he hurried away.\n\nThe wolf ran ahead to the grandmother's cottage and knocked on the door.\n\n\"Who is it?\" called the grandmother from inside.\n\n\"It's Little Red Riding Hood,\" the wolf said, disguising his voice. \"I've brought you some food.\"\n\nThe grandmother, who was in bed, called out, \"Pull the string, and the latch will open.\"\n\nThe wolf pulled the string, opened the door, and without saying another word, he swallowed the grandmother whole. Then he put on her nightcap and nightgown and got into her bed, pulling the covers up to his nose.\n\nSoon, Little Red Riding Hood arrived at the cottage and knocked on the door.\n\n\"Who is it?\" called the wolf, trying to sound like the grandmother.\n\n\"It's Little Red Riding Hood. I've brought you some food,\" she replied.\n\n\"Pull the string, and the latch will open,\" said the wolf.\n\nLittle Red Riding Hood pulled the string, opened the door, and went inside. She was surprised to see how different her grandmother looked.\n\n\"Grandmother, what big eyes you have!\" she exclaimed.\n\n\"All the better to see you with, my dear,\" replied the wolf.\n\n\"Grandmother, what big ears you have!\"\n\n\"All the better to hear you with, my dear.\"\n\n\"Grandmother, what big teeth you have!\"\n\n\"All the better to eat you with!\" growled the wolf, and he leaped out of bed and swallowed Little Red Riding Hood whole, just as he had done with her grandmother.\n\nFeeling satisfied, the wolf climbed back into bed and fell asleep, snoring loudly.\n\nA hunter who was passing by the cottage heard the loud snoring and thought it strange that the old woman would snore so loudly. He decided to check if everything was alright.\n\nWhen the hunter entered the cottage, he saw the wolf lying in the bed, still wearing the grandmother's nightcap.\n\n\"So I've found you at last, you old sinner!\" said the hunter. \"I've been looking for you for a long time!\"\n\nThe hunter was about to shoot the wolf when he thought that the wolf might have eaten the grandmother. Instead of shooting, he took a pair of scissors and cut open the wolf's belly.\n\nTo his surprise, out jumped Little Red Riding Hood and her grandmother, both alive and well.\n\n\"Thank you, kind hunter,\" they said gratefully.\n\nLittle Red Riding Hood quickly gathered some heavy stones, and they filled the wolf's belly with them while he was still asleep. When the wolf woke up, he tried to run away, but the stones were so heavy that he collapsed and died.\n\nThe hunter took the wolf's pelt, the grandmother enjoyed the food that Little Red Riding Hood had brought, and Little Red Riding Hood promised herself never to talk to strangers in the forest again.\n\nAnd they all lived happily ever after.\n\"\"\"\n</code></pre>"},{"location":"api/llm-bridge/#narrative.llm.llm_renderer.OpenAIAdapter","title":"<code>OpenAIAdapter</code>","text":"<p>             Bases: <code>LLMAdapter</code></p> <p>An adapter for the OpenAI API.</p> <p>This adapter uses the OpenAI API to generate text from prompts.</p> Source code in <code>narrative/llm/llm_renderer.py</code> <pre><code>class OpenAIAdapter(LLMAdapter):\n    \"\"\"\n    An adapter for the OpenAI API.\n\n    This adapter uses the OpenAI API to generate text from prompts.\n    \"\"\"\n\n    def __init__(self, api_key: str, model: str = \"gpt-4\"):\n        \"\"\"\n        Initialize an OpenAIAdapter.\n\n        Args:\n            api_key: The OpenAI API key.\n            model: The model to use (default: \"gpt-4\").\n        \"\"\"\n        try:\n            import openai\n        except ImportError as err:\n            raise ImportError(\n                \"OpenAI is required for this adapter. \"\n                \"Install it with 'pip install openai'.\"\n            ) from err\n\n        self.client = openai.OpenAI(api_key=api_key)\n        self.model = model\n\n    def generate(self, prompt: str) -&gt; str:\n        \"\"\"\n        Generate text from a prompt using the OpenAI API.\n\n        Args:\n            prompt: The prompt to send to the OpenAI API.\n\n        Returns:\n            The generated text.\n        \"\"\"\n        response = self.client.chat.completions.create(\n            model=self.model,\n            messages=[\n                {\"role\": \"system\", \"content\": \"You are a creative storyteller.\"},\n                {\"role\": \"user\", \"content\": prompt},\n            ],\n            temperature=0.7,\n            max_tokens=2000,\n        )\n\n        content = response.choices[0].message.content\n        if content is None:\n            return \"\"\n        # Explicitly convert to string to satisfy mypy\n        return str(content)\n</code></pre>"},{"location":"api/llm-bridge/#narrative.llm.llm_renderer.OpenAIAdapter.__init__","title":"<code>__init__(api_key, model='gpt-4')</code>","text":"<p>Initialize an OpenAIAdapter.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The OpenAI API key.</p> required <code>model</code> <code>str</code> <p>The model to use (default: \"gpt-4\").</p> <code>'gpt-4'</code> Source code in <code>narrative/llm/llm_renderer.py</code> <pre><code>def __init__(self, api_key: str, model: str = \"gpt-4\"):\n    \"\"\"\n    Initialize an OpenAIAdapter.\n\n    Args:\n        api_key: The OpenAI API key.\n        model: The model to use (default: \"gpt-4\").\n    \"\"\"\n    try:\n        import openai\n    except ImportError as err:\n        raise ImportError(\n            \"OpenAI is required for this adapter. \"\n            \"Install it with 'pip install openai'.\"\n        ) from err\n\n    self.client = openai.OpenAI(api_key=api_key)\n    self.model = model\n</code></pre>"},{"location":"api/llm-bridge/#narrative.llm.llm_renderer.OpenAIAdapter.generate","title":"<code>generate(prompt)</code>","text":"<p>Generate text from a prompt using the OpenAI API.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt to send to the OpenAI API.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated text.</p> Source code in <code>narrative/llm/llm_renderer.py</code> <pre><code>def generate(self, prompt: str) -&gt; str:\n    \"\"\"\n    Generate text from a prompt using the OpenAI API.\n\n    Args:\n        prompt: The prompt to send to the OpenAI API.\n\n    Returns:\n        The generated text.\n    \"\"\"\n    response = self.client.chat.completions.create(\n        model=self.model,\n        messages=[\n            {\"role\": \"system\", \"content\": \"You are a creative storyteller.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ],\n        temperature=0.7,\n        max_tokens=2000,\n    )\n\n    content = response.choices[0].message.content\n    if content is None:\n        return \"\"\n    # Explicitly convert to string to satisfy mypy\n    return str(content)\n</code></pre>"},{"location":"api/trajectory-explorer/","title":"Trajectory Explorer","text":"<p>Trajectory Explorer</p> <p>This module contains the TrajectoryExplorer class, which generates and ranks trajectories through an Intention Dependency Graph (IDG).</p>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.CoherenceMetric","title":"<code>CoherenceMetric</code>","text":"<p>A metric that scores trajectories based on coherence.</p> <p>Coherence is measured by the continuity of characters and locations between adjacent intentions.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>class CoherenceMetric:\n    \"\"\"\n    A metric that scores trajectories based on coherence.\n\n    Coherence is measured by the continuity of characters and locations\n    between adjacent intentions.\n    \"\"\"\n\n    def score(self, trajectory: Trajectory) -&gt; float:\n        \"\"\"\n        Score a trajectory based on coherence.\n\n        Args:\n            trajectory: The trajectory to score.\n\n        Returns:\n            A coherence score between 0 and 1.\n        \"\"\"\n        if len(trajectory.intentions) &lt;= 1:\n            return 1.0  # A single intention is maximally coherent\n\n        continuity_score = 0.0\n\n        for i in range(len(trajectory.intentions) - 1):\n            current = trajectory.intentions[i]\n            next_intention = trajectory.intentions[i + 1]\n\n            # Check character continuity\n            character_continuity = (\n                current[\"character\"] == next_intention[\"character\"]\n                or current[\"character\"] == next_intention[\"target\"]\n                or current[\"target\"] == next_intention[\"character\"]\n                or current[\"target\"] == next_intention[\"target\"]\n            )\n\n            # Check location continuity\n            location_continuity = current[\"location\"] == next_intention[\"location\"]\n\n            # Combine continuity scores (equal weighting)\n            pair_score = (int(character_continuity) + int(location_continuity)) / 2\n            continuity_score += pair_score\n\n        return continuity_score / (len(trajectory.intentions) - 1)\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.CoherenceMetric.score","title":"<code>score(trajectory)</code>","text":"<p>Score a trajectory based on coherence.</p> <p>Parameters:</p> Name Type Description Default <code>trajectory</code> <code>Trajectory</code> <p>The trajectory to score.</p> required <p>Returns:</p> Type Description <code>float</code> <p>A coherence score between 0 and 1.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>def score(self, trajectory: Trajectory) -&gt; float:\n    \"\"\"\n    Score a trajectory based on coherence.\n\n    Args:\n        trajectory: The trajectory to score.\n\n    Returns:\n        A coherence score between 0 and 1.\n    \"\"\"\n    if len(trajectory.intentions) &lt;= 1:\n        return 1.0  # A single intention is maximally coherent\n\n    continuity_score = 0.0\n\n    for i in range(len(trajectory.intentions) - 1):\n        current = trajectory.intentions[i]\n        next_intention = trajectory.intentions[i + 1]\n\n        # Check character continuity\n        character_continuity = (\n            current[\"character\"] == next_intention[\"character\"]\n            or current[\"character\"] == next_intention[\"target\"]\n            or current[\"target\"] == next_intention[\"character\"]\n            or current[\"target\"] == next_intention[\"target\"]\n        )\n\n        # Check location continuity\n        location_continuity = current[\"location\"] == next_intention[\"location\"]\n\n        # Combine continuity scores (equal weighting)\n        pair_score = (int(character_continuity) + int(location_continuity)) / 2\n        continuity_score += pair_score\n\n    return continuity_score / (len(trajectory.intentions) - 1)\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.DramaMetric","title":"<code>DramaMetric</code>","text":"<p>A metric that scores trajectories based on dramatic potential.</p> <p>Drama is measured by the presence of conflict, character arcs, and emotional intensity.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>class DramaMetric:\n    \"\"\"\n    A metric that scores trajectories based on dramatic potential.\n\n    Drama is measured by the presence of conflict, character arcs,\n    and emotional intensity.\n    \"\"\"\n\n    def score(self, trajectory: Trajectory) -&gt; float:\n        \"\"\"\n        Score a trajectory based on dramatic potential.\n\n        Args:\n            trajectory: The trajectory to score.\n\n        Returns:\n            A drama score between 0 and 1.\n        \"\"\"\n        if not trajectory.intentions:\n            return 0.0\n\n        # Count conflict indicators\n        conflict_count = 0\n        character_arcs = set()\n        emotional_intensity = 0.0\n\n        # Keywords that indicate conflict or emotional intensity\n        conflict_keywords = {\n            \"eat\",\n            \"kill\",\n            \"attack\",\n            \"fight\",\n            \"steal\",\n            \"trick\",\n            \"deceive\",\n        }\n        emotional_keywords = {\n            \"love\",\n            \"hate\",\n            \"fear\",\n            \"anger\",\n            \"joy\",\n            \"sadness\",\n            \"surprise\",\n        }\n\n        for intention in trajectory.intentions:\n            # Check for conflict in intention ID\n            for keyword in conflict_keywords:\n                if keyword in intention[\"id\"]:\n                    conflict_count += 1\n                    break\n\n            # Track character arcs (characters that appear in multiple intentions)\n            character_arcs.add(intention[\"character\"])\n            character_arcs.add(intention[\"target\"])\n\n            # Check for emotional intensity in intention ID or description\n            for keyword in emotional_keywords:\n                if keyword in intention[\"id\"]:\n                    emotional_intensity += 1\n                    break\n                if intention.get(\"description\") and keyword in intention[\"description\"]:\n                    emotional_intensity += 0.5\n                    break\n\n        # Calculate scores\n        conflict_score = min(1.0, conflict_count / len(trajectory.intentions))\n        character_arc_score = min(\n            1.0, len(character_arcs) / (2 * len(trajectory.intentions))\n        )\n        emotional_score = min(1.0, emotional_intensity / len(trajectory.intentions))\n\n        # Combine scores (equal weighting)\n        return (conflict_score + character_arc_score + emotional_score) / 3\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.DramaMetric.score","title":"<code>score(trajectory)</code>","text":"<p>Score a trajectory based on dramatic potential.</p> <p>Parameters:</p> Name Type Description Default <code>trajectory</code> <code>Trajectory</code> <p>The trajectory to score.</p> required <p>Returns:</p> Type Description <code>float</code> <p>A drama score between 0 and 1.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>def score(self, trajectory: Trajectory) -&gt; float:\n    \"\"\"\n    Score a trajectory based on dramatic potential.\n\n    Args:\n        trajectory: The trajectory to score.\n\n    Returns:\n        A drama score between 0 and 1.\n    \"\"\"\n    if not trajectory.intentions:\n        return 0.0\n\n    # Count conflict indicators\n    conflict_count = 0\n    character_arcs = set()\n    emotional_intensity = 0.0\n\n    # Keywords that indicate conflict or emotional intensity\n    conflict_keywords = {\n        \"eat\",\n        \"kill\",\n        \"attack\",\n        \"fight\",\n        \"steal\",\n        \"trick\",\n        \"deceive\",\n    }\n    emotional_keywords = {\n        \"love\",\n        \"hate\",\n        \"fear\",\n        \"anger\",\n        \"joy\",\n        \"sadness\",\n        \"surprise\",\n    }\n\n    for intention in trajectory.intentions:\n        # Check for conflict in intention ID\n        for keyword in conflict_keywords:\n            if keyword in intention[\"id\"]:\n                conflict_count += 1\n                break\n\n        # Track character arcs (characters that appear in multiple intentions)\n        character_arcs.add(intention[\"character\"])\n        character_arcs.add(intention[\"target\"])\n\n        # Check for emotional intensity in intention ID or description\n        for keyword in emotional_keywords:\n            if keyword in intention[\"id\"]:\n                emotional_intensity += 1\n                break\n            if intention.get(\"description\") and keyword in intention[\"description\"]:\n                emotional_intensity += 0.5\n                break\n\n    # Calculate scores\n    conflict_score = min(1.0, conflict_count / len(trajectory.intentions))\n    character_arc_score = min(\n        1.0, len(character_arcs) / (2 * len(trajectory.intentions))\n    )\n    emotional_score = min(1.0, emotional_intensity / len(trajectory.intentions))\n\n    # Combine scores (equal weighting)\n    return (conflict_score + character_arc_score + emotional_score) / 3\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.MetricProtocol","title":"<code>MetricProtocol</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Protocol for trajectory metrics.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>class MetricProtocol(Protocol):\n    \"\"\"Protocol for trajectory metrics.\"\"\"\n\n    def score(self, trajectory: Trajectory) -&gt; float:\n        \"\"\"Score a trajectory.\"\"\"\n        ...\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.MetricProtocol.score","title":"<code>score(trajectory)</code>","text":"<p>Score a trajectory.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>def score(self, trajectory: Trajectory) -&gt; float:\n    \"\"\"Score a trajectory.\"\"\"\n    ...\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.NoveltyMetric","title":"<code>NoveltyMetric</code>","text":"<p>A metric that scores trajectories based on novelty.</p> <p>Novelty is measured by the diversity of characters, locations, and intention types.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>class NoveltyMetric:\n    \"\"\"\n    A metric that scores trajectories based on novelty.\n\n    Novelty is measured by the diversity of characters, locations, and intention types.\n    \"\"\"\n\n    def score(self, trajectory: Trajectory) -&gt; float:\n        \"\"\"\n        Score a trajectory based on novelty.\n\n        Args:\n            trajectory: The trajectory to score.\n\n        Returns:\n            A novelty score between 0 and 1.\n        \"\"\"\n        if not trajectory.intentions:\n            return 0.0\n\n        # Count unique characters, locations, and intention IDs\n        characters = set()\n        locations = set()\n        intention_ids = set()\n\n        for intention in trajectory.intentions:\n            characters.add(intention[\"character\"])\n            characters.add(intention[\"target\"])\n            locations.add(intention[\"location\"])\n            intention_ids.add(intention[\"id\"])\n\n        # Calculate diversity scores\n        character_diversity = len(characters) / (2 * len(trajectory.intentions))\n        location_diversity = len(locations) / len(trajectory.intentions)\n        intention_diversity = len(intention_ids) / len(trajectory.intentions)\n\n        # Combine scores (equal weighting)\n        return (character_diversity + location_diversity + intention_diversity) / 3\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.NoveltyMetric.score","title":"<code>score(trajectory)</code>","text":"<p>Score a trajectory based on novelty.</p> <p>Parameters:</p> Name Type Description Default <code>trajectory</code> <code>Trajectory</code> <p>The trajectory to score.</p> required <p>Returns:</p> Type Description <code>float</code> <p>A novelty score between 0 and 1.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>def score(self, trajectory: Trajectory) -&gt; float:\n    \"\"\"\n    Score a trajectory based on novelty.\n\n    Args:\n        trajectory: The trajectory to score.\n\n    Returns:\n        A novelty score between 0 and 1.\n    \"\"\"\n    if not trajectory.intentions:\n        return 0.0\n\n    # Count unique characters, locations, and intention IDs\n    characters = set()\n    locations = set()\n    intention_ids = set()\n\n    for intention in trajectory.intentions:\n        characters.add(intention[\"character\"])\n        characters.add(intention[\"target\"])\n        locations.add(intention[\"location\"])\n        intention_ids.add(intention[\"id\"])\n\n    # Calculate diversity scores\n    character_diversity = len(characters) / (2 * len(trajectory.intentions))\n    location_diversity = len(locations) / len(trajectory.intentions)\n    intention_diversity = len(intention_ids) / len(trajectory.intentions)\n\n    # Combine scores (equal weighting)\n    return (character_diversity + location_diversity + intention_diversity) / 3\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.Trajectory","title":"<code>Trajectory</code>  <code>dataclass</code>","text":"<p>A trajectory through an IDG.</p> <p>A trajectory is a sequence of intentions that form a coherent narrative path.</p> <p>Attributes:</p> Name Type Description <code>intentions</code> <code>List[Dict[str, Any]]</code> <p>A list of intention data dictionaries.</p> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optional additional data associated with the trajectory.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>@dataclass\nclass Trajectory:\n    \"\"\"\n    A trajectory through an IDG.\n\n    A trajectory is a sequence of intentions that form a coherent narrative path.\n\n    Attributes:\n        intentions: A list of intention data dictionaries.\n        metadata: Optional additional data associated with the trajectory.\n    \"\"\"\n\n    intentions: List[Dict[str, Any]]\n    metadata: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.TrajectoryExplorer","title":"<code>TrajectoryExplorer</code>","text":"<p>Explorer class for generating and ranking trajectories through an IDG.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>class TrajectoryExplorer:\n    \"\"\"\n    Explorer class for generating and ranking trajectories through an IDG.\n    \"\"\"\n\n    def __init__(self, idg: IDG):\n        \"\"\"\n        Initialize a TrajectoryExplorer with an IDG.\n\n        Args:\n            idg: The IDG to explore.\n        \"\"\"\n        self.idg = idg\n        self.metrics = {\n            \"novelty\": NoveltyMetric(),\n            \"coherence\": CoherenceMetric(),\n            \"drama\": DramaMetric(),\n        }\n\n    def get_trajectories(\n        self, max_length: int = 5, start_intentions: Optional[List[str]] = None\n    ) -&gt; List[Trajectory]:\n        \"\"\"\n        Generate all possible trajectories through the IDG up to a maximum length.\n\n        Args:\n            max_length: The maximum length of trajectories to generate.\n            start_intentions: Optional list of intention IDs to start trajectories from.\n                If not provided, trajectories will start from all root intentions.\n\n        Returns:\n            A list of trajectories.\n        \"\"\"\n        if start_intentions is None:\n            start_intentions = list(self.idg.get_root_intentions())\n\n        trajectories: List[Trajectory] = []\n\n        for start_intention in start_intentions:\n            # Start with a trajectory containing just the start intention\n            intention_data = self.idg.get_intention_data(start_intention)\n            initial_trajectory = Trajectory(\n                intentions=[{\"id\": start_intention, **intention_data}]\n            )\n\n            # Use DFS to explore all possible trajectories\n            self._explore_trajectories(initial_trajectory, max_length, trajectories)\n\n        return trajectories\n\n    def _explore_trajectories(\n        self,\n        current_trajectory: Trajectory,\n        max_length: int,\n        all_trajectories: List[Trajectory],\n    ) -&gt; None:\n        \"\"\"\n        Recursively explore all possible trajectories from a starting trajectory.\n\n        Args:\n            current_trajectory: The current trajectory being explored.\n            max_length: The maximum length of trajectories to generate.\n            all_trajectories: A list to store all generated trajectories.\n        \"\"\"\n        # Add the current trajectory to the list\n        all_trajectories.append(current_trajectory)\n\n        # If we've reached the maximum length, stop exploring\n        if len(current_trajectory.intentions) &gt;= max_length:\n            return\n\n        # Get the last intention in the current trajectory\n        last_intention_id = current_trajectory.intentions[-1][\"id\"]\n\n        # Find all intentions that depend on the last intention\n        for successor in self.idg.successors(last_intention_id):\n            # Create a new trajectory by adding the successor\n            successor_data = self.idg.get_intention_data(successor)\n            new_intentions = current_trajectory.intentions + [\n                {\"id\": successor, **successor_data}\n            ]\n            new_trajectory = Trajectory(intentions=new_intentions)\n\n            # Recursively explore from the new trajectory\n            self._explore_trajectories(new_trajectory, max_length, all_trajectories)\n\n    def rank_trajectories(\n        self,\n        trajectories: List[Trajectory],\n        metric: Union[str, MetricProtocol] = \"novelty\",\n    ) -&gt; List[Trajectory]:\n        \"\"\"\n        Rank trajectories according to a metric.\n\n        Args:\n            trajectories: The trajectories to rank.\n            metric: The metric to use for ranking. Can be a string\n                (name of a built-in metric)\n                or a custom metric object with a score method.\n\n        Returns:\n            A list of trajectories sorted by score (highest first).\n\n        Raises:\n            ValueError: If the metric name is not recognized.\n        \"\"\"\n        # Handle string metric names\n        if isinstance(metric, str):\n            if metric not in self.metrics:\n                raise ValueError(f\"Unknown metric: {metric}\")\n            metric_obj = self.metrics[metric]\n\n            # Score and sort trajectories\n            scored_trajectories: List[tuple[Trajectory, float]] = [\n                (t, metric_obj.score(t)) for t in trajectories\n            ]\n            scored_trajectories.sort(key=lambda x: x[1], reverse=True)\n\n            return [t for t, _ in scored_trajectories]\n\n        # For custom metric objects, we need to use a different approach\n        # First, ensure it has a score method\n        if not hasattr(metric, \"score\") or not callable(metric.score):\n            raise ValueError(\"Custom metric must have a 'score' method\")\n\n        # mypy: disable-error-code=\"attr-defined\"\n        custom_metric = metric  # type: ignore\n\n        # Score and sort trajectories\n        scored_trajectories = []\n        for t in trajectories:\n            try:\n                # This is safe because we've checked that the method exists\n                # and is callable\n                score = custom_metric.score(t)  # type: ignore\n                scored_trajectories.append((t, score))\n            except Exception as e:\n                raise ValueError(f\"Error scoring trajectory: {e}\") from e\n\n        scored_trajectories.sort(key=lambda x: x[1], reverse=True)\n        return [t for t, _ in scored_trajectories]\n\n    def add_metric(self, name: str, metric: MetricProtocol) -&gt; None:\n        \"\"\"\n        Add a custom metric.\n\n        Args:\n            name: The name of the metric.\n            metric: The metric object.\n        \"\"\"\n        self.metrics[name] = metric\n\n    def get_random_trajectory(\n        self, max_length: int = 5, start_intentions: Optional[List[str]] = None\n    ) -&gt; Trajectory:\n        \"\"\"\n        Generate a random trajectory through the IDG.\n\n        Args:\n            max_length: The maximum length of the trajectory.\n            start_intentions: Optional list of intention IDs\n                to start the trajectory from.\n                If not provided, the trajectory will start\n                from a random root intention.\n\n        Returns:\n            A random trajectory.\n        \"\"\"\n        if start_intentions is None:\n            start_intentions = list(self.idg.get_root_intentions())\n\n        # Choose a random start intention\n        start_intention = random.choice(start_intentions)\n        intention_data = self.idg.get_intention_data(start_intention)\n        trajectory = Trajectory(intentions=[{\"id\": start_intention, **intention_data}])\n\n        # Build the trajectory by randomly choosing successors\n        current_intention = start_intention\n        while len(trajectory.intentions) &lt; max_length:\n            # Get all successors of the current intention\n            successors = list(self.idg.successors(current_intention))\n            if not successors:\n                break  # No more successors, end the trajectory\n\n            # Choose a random successor\n            next_intention = random.choice(successors)\n            next_data = self.idg.get_intention_data(next_intention)\n            trajectory.intentions.append({\"id\": next_intention, **next_data})\n\n            current_intention = next_intention\n\n        return trajectory\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.TrajectoryExplorer.__init__","title":"<code>__init__(idg)</code>","text":"<p>Initialize a TrajectoryExplorer with an IDG.</p> <p>Parameters:</p> Name Type Description Default <code>idg</code> <code>IDG</code> <p>The IDG to explore.</p> required Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>def __init__(self, idg: IDG):\n    \"\"\"\n    Initialize a TrajectoryExplorer with an IDG.\n\n    Args:\n        idg: The IDG to explore.\n    \"\"\"\n    self.idg = idg\n    self.metrics = {\n        \"novelty\": NoveltyMetric(),\n        \"coherence\": CoherenceMetric(),\n        \"drama\": DramaMetric(),\n    }\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.TrajectoryExplorer.add_metric","title":"<code>add_metric(name, metric)</code>","text":"<p>Add a custom metric.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the metric.</p> required <code>metric</code> <code>MetricProtocol</code> <p>The metric object.</p> required Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>def add_metric(self, name: str, metric: MetricProtocol) -&gt; None:\n    \"\"\"\n    Add a custom metric.\n\n    Args:\n        name: The name of the metric.\n        metric: The metric object.\n    \"\"\"\n    self.metrics[name] = metric\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.TrajectoryExplorer.get_random_trajectory","title":"<code>get_random_trajectory(max_length=5, start_intentions=None)</code>","text":"<p>Generate a random trajectory through the IDG.</p> <p>Parameters:</p> Name Type Description Default <code>max_length</code> <code>int</code> <p>The maximum length of the trajectory.</p> <code>5</code> <code>start_intentions</code> <code>Optional[List[str]]</code> <p>Optional list of intention IDs to start the trajectory from. If not provided, the trajectory will start from a random root intention.</p> <code>None</code> <p>Returns:</p> Type Description <code>Trajectory</code> <p>A random trajectory.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>def get_random_trajectory(\n    self, max_length: int = 5, start_intentions: Optional[List[str]] = None\n) -&gt; Trajectory:\n    \"\"\"\n    Generate a random trajectory through the IDG.\n\n    Args:\n        max_length: The maximum length of the trajectory.\n        start_intentions: Optional list of intention IDs\n            to start the trajectory from.\n            If not provided, the trajectory will start\n            from a random root intention.\n\n    Returns:\n        A random trajectory.\n    \"\"\"\n    if start_intentions is None:\n        start_intentions = list(self.idg.get_root_intentions())\n\n    # Choose a random start intention\n    start_intention = random.choice(start_intentions)\n    intention_data = self.idg.get_intention_data(start_intention)\n    trajectory = Trajectory(intentions=[{\"id\": start_intention, **intention_data}])\n\n    # Build the trajectory by randomly choosing successors\n    current_intention = start_intention\n    while len(trajectory.intentions) &lt; max_length:\n        # Get all successors of the current intention\n        successors = list(self.idg.successors(current_intention))\n        if not successors:\n            break  # No more successors, end the trajectory\n\n        # Choose a random successor\n        next_intention = random.choice(successors)\n        next_data = self.idg.get_intention_data(next_intention)\n        trajectory.intentions.append({\"id\": next_intention, **next_data})\n\n        current_intention = next_intention\n\n    return trajectory\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.TrajectoryExplorer.get_trajectories","title":"<code>get_trajectories(max_length=5, start_intentions=None)</code>","text":"<p>Generate all possible trajectories through the IDG up to a maximum length.</p> <p>Parameters:</p> Name Type Description Default <code>max_length</code> <code>int</code> <p>The maximum length of trajectories to generate.</p> <code>5</code> <code>start_intentions</code> <code>Optional[List[str]]</code> <p>Optional list of intention IDs to start trajectories from. If not provided, trajectories will start from all root intentions.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Trajectory]</code> <p>A list of trajectories.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>def get_trajectories(\n    self, max_length: int = 5, start_intentions: Optional[List[str]] = None\n) -&gt; List[Trajectory]:\n    \"\"\"\n    Generate all possible trajectories through the IDG up to a maximum length.\n\n    Args:\n        max_length: The maximum length of trajectories to generate.\n        start_intentions: Optional list of intention IDs to start trajectories from.\n            If not provided, trajectories will start from all root intentions.\n\n    Returns:\n        A list of trajectories.\n    \"\"\"\n    if start_intentions is None:\n        start_intentions = list(self.idg.get_root_intentions())\n\n    trajectories: List[Trajectory] = []\n\n    for start_intention in start_intentions:\n        # Start with a trajectory containing just the start intention\n        intention_data = self.idg.get_intention_data(start_intention)\n        initial_trajectory = Trajectory(\n            intentions=[{\"id\": start_intention, **intention_data}]\n        )\n\n        # Use DFS to explore all possible trajectories\n        self._explore_trajectories(initial_trajectory, max_length, trajectories)\n\n    return trajectories\n</code></pre>"},{"location":"api/trajectory-explorer/#narrative.core.trajectory_explorer.TrajectoryExplorer.rank_trajectories","title":"<code>rank_trajectories(trajectories, metric='novelty')</code>","text":"<p>Rank trajectories according to a metric.</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>List[Trajectory]</code> <p>The trajectories to rank.</p> required <code>metric</code> <code>Union[str, MetricProtocol]</code> <p>The metric to use for ranking. Can be a string (name of a built-in metric) or a custom metric object with a score method.</p> <code>'novelty'</code> <p>Returns:</p> Type Description <code>List[Trajectory]</code> <p>A list of trajectories sorted by score (highest first).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the metric name is not recognized.</p> Source code in <code>narrative/core/trajectory_explorer.py</code> <pre><code>def rank_trajectories(\n    self,\n    trajectories: List[Trajectory],\n    metric: Union[str, MetricProtocol] = \"novelty\",\n) -&gt; List[Trajectory]:\n    \"\"\"\n    Rank trajectories according to a metric.\n\n    Args:\n        trajectories: The trajectories to rank.\n        metric: The metric to use for ranking. Can be a string\n            (name of a built-in metric)\n            or a custom metric object with a score method.\n\n    Returns:\n        A list of trajectories sorted by score (highest first).\n\n    Raises:\n        ValueError: If the metric name is not recognized.\n    \"\"\"\n    # Handle string metric names\n    if isinstance(metric, str):\n        if metric not in self.metrics:\n            raise ValueError(f\"Unknown metric: {metric}\")\n        metric_obj = self.metrics[metric]\n\n        # Score and sort trajectories\n        scored_trajectories: List[tuple[Trajectory, float]] = [\n            (t, metric_obj.score(t)) for t in trajectories\n        ]\n        scored_trajectories.sort(key=lambda x: x[1], reverse=True)\n\n        return [t for t, _ in scored_trajectories]\n\n    # For custom metric objects, we need to use a different approach\n    # First, ensure it has a score method\n    if not hasattr(metric, \"score\") or not callable(metric.score):\n        raise ValueError(\"Custom metric must have a 'score' method\")\n\n    # mypy: disable-error-code=\"attr-defined\"\n    custom_metric = metric  # type: ignore\n\n    # Score and sort trajectories\n    scored_trajectories = []\n    for t in trajectories:\n        try:\n            # This is safe because we've checked that the method exists\n            # and is callable\n            score = custom_metric.score(t)  # type: ignore\n            scored_trajectories.append((t, score))\n        except Exception as e:\n            raise ValueError(f\"Error scoring trajectory: {e}\") from e\n\n    scored_trajectories.sort(key=lambda x: x[1], reverse=True)\n    return [t for t, _ in scored_trajectories]\n</code></pre>"},{"location":"examples/advanced-usage/","title":"Advanced Usage","text":"<p>This guide covers advanced usage patterns and techniques for the Narrative library.</p>"},{"location":"examples/advanced-usage/#advanced-trajectory-generation","title":"Advanced Trajectory Generation","text":""},{"location":"examples/advanced-usage/#custom-trajectory-filters","title":"Custom Trajectory Filters","text":"<p>You can create custom filters to select specific trajectories based on your criteria:</p> <pre><code>from narrative.core.trajectory_explorer import TrajectoryExplorer\n\n# Create a trajectory explorer\nexplorer = TrajectoryExplorer(idg)\n\n# Generate all possible trajectories\nall_trajectories = explorer.get_trajectories(max_length=7)\n\n# Filter trajectories with custom criteria\ndef custom_filter(trajectory):\n    # Example: Only include trajectories where the hero defeats the villain\n    for intention in trajectory.intentions:\n        if intention[\"id\"] == \"defeat_villain\" and intention[\"character\"] == \"hero\":\n            return True\n    return False\n\nfiltered_trajectories = [t for t in all_trajectories if custom_filter(t)]\nprint(f\"Found {len(filtered_trajectories)} trajectories where the hero defeats the villain.\")\n</code></pre>"},{"location":"examples/advanced-usage/#trajectory-combination","title":"Trajectory Combination","text":"<p>You can combine multiple trajectories to create more complex narratives:</p> <pre><code>from narrative.core.trajectory_explorer import Trajectory\n\n# Assume we have two trajectories\ntrajectory1 = explorer.get_random_trajectory(max_length=3)\ntrajectory2 = explorer.get_random_trajectory(max_length=3)\n\n# Combine trajectories (simple concatenation)\ncombined_intentions = trajectory1.intentions + trajectory2.intentions\ncombined_trajectory = Trajectory(combined_intentions, trajectory1.domain)\n\n# Render the combined trajectory\nrenderer = LLMRenderer()\ncombined_story = renderer.render(combined_trajectory)\n</code></pre>"},{"location":"examples/advanced-usage/#trajectory-manipulation","title":"Trajectory Manipulation","text":"<p>You can manipulate trajectories to create variations:</p> <pre><code># Get a trajectory\ntrajectory = explorer.get_random_trajectory(max_length=5)\n\n# Remove an intention\nmodified_intentions = [i for i in trajectory.intentions if i[\"id\"] != \"defeat_villain\"]\nmodified_trajectory = Trajectory(modified_intentions, trajectory.domain)\n\n# Insert a new intention at a specific position\nnew_intention = {\n    \"id\": \"call_for_help\",\n    \"character\": \"sidekick\",\n    \"target\": \"hero\",\n    \"location\": \"forest\",\n    \"description\": \"to request assistance\"\n}\nmodified_intentions.insert(2, new_intention)\nmodified_trajectory = Trajectory(modified_intentions, trajectory.domain)\n\n# Render the modified trajectory\nmodified_story = renderer.render(modified_trajectory)\n</code></pre>"},{"location":"examples/advanced-usage/#advanced-llm-integration","title":"Advanced LLM Integration","text":""},{"location":"examples/advanced-usage/#custom-llm-adapters","title":"Custom LLM Adapters","text":"<p>You can create custom adapters for different LLM providers:</p> <pre><code>from narrative.llm.llm_renderer import LLMAdapter\n\nclass CustomLLMAdapter(LLMAdapter):\n    \"\"\"A custom adapter for a specific LLM provider.\"\"\"\n\n    def __init__(self, api_key, model=\"default-model\"):\n        self.api_key = api_key\n        self.model = model\n        # Initialize any client libraries or connections\n\n    def generate(self, prompt):\n        \"\"\"Generate text from the LLM based on the prompt.\"\"\"\n        # Implement the API call to your LLM provider\n        # This is a placeholder implementation\n        try:\n            # Make API call to LLM provider\n            response = self._call_llm_api(prompt)\n            return response\n        except Exception as e:\n            print(f\"Error generating text: {e}\")\n            return \"Error generating story.\"\n\n    def _call_llm_api(self, prompt):\n        \"\"\"Make the actual API call to the LLM provider.\"\"\"\n        # Implement the specific API call\n        # This is a placeholder\n        return f\"Generated story based on prompt: {prompt[:50]}...\"\n\n# Use the custom adapter\ncustom_adapter = CustomLLMAdapter(api_key=\"your-api-key\")\nrenderer = LLMRenderer(adapter=custom_adapter)\nstory = renderer.render(trajectory)\n</code></pre>"},{"location":"examples/advanced-usage/#custom-prompt-templates","title":"Custom Prompt Templates","text":"<p>You can create custom prompt templates for different storytelling styles:</p> <pre><code>from narrative.llm.llm_renderer import LLMRenderer\n\n# Define custom prompt templates\nfairy_tale_template = \"\"\"\nYou are a master storyteller specializing in fairy tales.\nCreate a fairy tale based on the following sequence of events:\n\n{trajectory_description}\n\nYour fairy tale should have a clear moral lesson and use language appropriate for children.\n\"\"\"\n\nnoir_template = \"\"\"\nYou are a hardboiled detective novelist from the 1940s.\nWrite a noir-style narrative based on the following sequence of events:\n\n{trajectory_description}\n\nUse terse, cynical language with vivid descriptions of urban settings and morally ambiguous characters.\n\"\"\"\n\nsci_fi_template = \"\"\"\nYou are a visionary science fiction author.\nCreate a futuristic sci-fi story based on the following sequence of events:\n\n{trajectory_description}\n\nIncorporate advanced technology, space travel, or other sci-fi elements while maintaining the core narrative.\n\"\"\"\n\n# Create renderers with different templates\nfairy_tale_renderer = LLMRenderer(prompt_template=fairy_tale_template)\nnoir_renderer = LLMRenderer(prompt_template=noir_template)\nsci_fi_renderer = LLMRenderer(prompt_template=sci_fi_template)\n\n# Render the same trajectory in different styles\nfairy_tale = fairy_tale_renderer.render(trajectory)\nnoir_story = noir_renderer.render(trajectory)\nsci_fi_story = sci_fi_renderer.render(trajectory)\n</code></pre>"},{"location":"examples/advanced-usage/#advanced-domain-modeling","title":"Advanced Domain Modeling","text":""},{"location":"examples/advanced-usage/#dynamic-domain-generation","title":"Dynamic Domain Generation","text":"<p>You can generate domains programmatically:</p> <pre><code>from narrative.schemas.domain import Domain\nimport random\n\ndef generate_random_domain(num_characters=5, num_locations=3, num_intentions=10):\n    \"\"\"Generate a random domain with the specified number of elements.\"\"\"\n    # Generate characters\n    characters = [f\"character_{i}\" for i in range(1, num_characters + 1)]\n\n    # Generate locations\n    locations = [f\"location_{i}\" for i in range(1, num_locations + 1)]\n\n    # Generate intentions\n    intentions = []\n    for i in range(1, num_intentions + 1):\n        character = random.choice(characters)\n        target = random.choice([c for c in characters if c != character])\n        location = random.choice(locations)\n\n        intention = {\n            \"id\": f\"intention_{i}\",\n            \"character\": character,\n            \"target\": target,\n            \"location\": location,\n            \"description\": f\"description of intention_{i}\"\n        }\n        intentions.append(intention)\n\n    # Generate dependencies\n    dependencies = []\n    intention_ids = [intention[\"id\"] for intention in intentions]\n\n    # Create some random dependencies\n    num_dependencies = min(len(intention_ids), num_intentions // 2)\n    for _ in range(num_dependencies):\n        from_intention = random.choice(intention_ids)\n        to_intention = random.choice([i for i in intention_ids if i != from_intention])\n        dependency_type = random.choice([\"intentional\", \"motivational\"])\n\n        dependency = {\n            \"from_intention\": from_intention,\n            \"to_intention\": to_intention,\n            \"type\": dependency_type,\n            \"description\": f\"dependency from {from_intention} to {to_intention}\"\n        }\n        dependencies.append(dependency)\n\n    # Create the domain\n    domain = Domain(\n        characters=characters,\n        locations=locations,\n        intentions=intentions,\n        dependencies=dependencies,\n        name=\"Randomly Generated Domain\",\n        description=\"A domain generated with random characters, locations, intentions, and dependencies.\"\n    )\n\n    return domain\n\n# Generate a random domain\nrandom_domain = generate_random_domain()\n\n# Build an IDG from the random domain\nidg_builder = IDGBuilder(random_domain)\nidg = idg_builder.build()\n\n# Validate the domain\nerrors = idg_builder.validate()\nif errors:\n    print(\"Domain validation errors:\")\n    for error in errors:\n        print(f\"- {error}\")\nelse:\n    print(\"Random domain is valid!\")\n</code></pre>"},{"location":"examples/advanced-usage/#domain-transformation","title":"Domain Transformation","text":"<p>You can transform domains to create variations:</p> <pre><code>def transform_domain(domain, transformation_type):\n    \"\"\"Transform a domain according to the specified transformation type.\"\"\"\n    # Create a copy of the domain\n    transformed_domain = Domain(\n        characters=domain.characters.copy(),\n        locations=domain.locations.copy(),\n        intentions=[intention.copy() for intention in domain.intentions],\n        dependencies=[dependency.copy() for dependency in domain.dependencies],\n        name=f\"{domain.name} ({transformation_type})\",\n        description=f\"{domain.description} - Transformed with {transformation_type}.\"\n    )\n\n    if transformation_type == \"role_reversal\":\n        # Swap the roles of two characters\n        if len(domain.characters) &gt;= 2:\n            char1, char2 = domain.characters[0], domain.characters[1]\n\n            # Update intentions\n            for intention in transformed_domain.intentions:\n                if intention[\"character\"] == char1:\n                    intention[\"character\"] = char2\n                elif intention[\"character\"] == char2:\n                    intention[\"character\"] = char1\n\n                if intention[\"target\"] == char1:\n                    intention[\"target\"] = char2\n                elif intention[\"target\"] == char2:\n                    intention[\"target\"] = char1\n\n    elif transformation_type == \"location_shift\":\n        # Change all instances of one location to another\n        if len(domain.locations) &gt;= 2:\n            loc1, loc2 = domain.locations[0], domain.locations[1]\n\n            # Update intentions\n            for intention in transformed_domain.intentions:\n                if intention[\"location\"] == loc1:\n                    intention[\"location\"] = loc2\n\n    elif transformation_type == \"add_character\":\n        # Add a new character and some intentions\n        new_character = f\"new_character_{len(domain.characters) + 1}\"\n        transformed_domain.characters.append(new_character)\n\n        # Add some intentions for the new character\n        for i in range(2):\n            target = random.choice([c for c in transformed_domain.characters if c != new_character])\n            location = random.choice(transformed_domain.locations)\n\n            new_intention = {\n                \"id\": f\"new_intention_{i+1}\",\n                \"character\": new_character,\n                \"target\": target,\n                \"location\": location,\n                \"description\": f\"new intention {i+1} for {new_character}\"\n            }\n            transformed_domain.intentions.append(new_intention)\n\n    return transformed_domain\n\n# Transform a domain with different transformations\nrole_reversal_domain = transform_domain(domain, \"role_reversal\")\nlocation_shift_domain = transform_domain(domain, \"location_shift\")\nadd_character_domain = transform_domain(domain, \"add_character\")\n\n# Build IDGs for the transformed domains\nrole_reversal_idg = IDGBuilder(role_reversal_domain).build()\nlocation_shift_idg = IDGBuilder(location_shift_domain).build()\nadd_character_idg = IDGBuilder(add_character_domain).build()\n</code></pre>"},{"location":"examples/advanced-usage/#advanced-visualization","title":"Advanced Visualization","text":""},{"location":"examples/advanced-usage/#custom-visualization-styles","title":"Custom Visualization Styles","text":"<p>You can customize the visualization of IDGs:</p> <pre><code>def visualize_idg_custom(idg, style=\"default\"):\n    \"\"\"Visualize an IDG with custom styling.\"\"\"\n    import matplotlib.pyplot as plt\n    import networkx as nx\n\n    # Create a directed graph\n    G = nx.DiGraph()\n\n    # Add nodes (intentions)\n    for intention_id in idg.get_intention_ids():\n        intention = idg.get_intention_data(intention_id)\n        G.add_node(intention_id, **intention)\n\n    # Add edges (dependencies)\n    for from_intention, to_intention in idg.get_dependency_pairs():\n        dependency = idg.get_dependency_data(from_intention, to_intention)\n        G.add_edge(from_intention, to_intention, **dependency)\n\n    # Set up the figure\n    plt.figure(figsize=(12, 8))\n\n    # Apply custom styling\n    if style == \"character_colored\":\n        # Color nodes by character\n        characters = idg.domain.characters\n        color_map = plt.cm.get_cmap(\"tab10\", len(characters))\n        character_colors = {char: color_map(i) for i, char in enumerate(characters)}\n\n        node_colors = [character_colors[G.nodes[node][\"character\"]] for node in G.nodes]\n\n        # Create a layout\n        pos = nx.spring_layout(G, seed=42)\n\n        # Draw the graph\n        nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=500)\n        nx.draw_networkx_edges(G, pos, edge_color=\"gray\", arrowsize=15)\n        nx.draw_networkx_labels(G, pos, font_size=10)\n\n        # Add a legend\n        legend_elements = [plt.Line2D([0], [0], marker='o', color='w',\n                          markerfacecolor=color, markersize=10, label=char)\n                          for char, color in character_colors.items()]\n        plt.legend(handles=legend_elements, title=\"Characters\")\n\n    elif style == \"dependency_types\":\n        # Color edges by dependency type\n        edge_colors = []\n        for u, v in G.edges():\n            if G.edges[u, v][\"type\"] == \"intentional\":\n                edge_colors.append(\"blue\")\n            else:  # motivational\n                edge_colors.append(\"red\")\n\n        # Create a layout\n        pos = nx.spring_layout(G, seed=42)\n\n        # Draw the graph\n        nx.draw_networkx_nodes(G, pos, node_color=\"lightgray\", node_size=500)\n        nx.draw_networkx_edges(G, pos, edge_color=edge_colors, arrowsize=15)\n        nx.draw_networkx_labels(G, pos, font_size=10)\n\n        # Add a legend\n        legend_elements = [\n            plt.Line2D([0], [0], color='blue', lw=2, label='Intentional'),\n            plt.Line2D([0], [0], color='red', lw=2, label='Motivational')\n        ]\n        plt.legend(handles=legend_elements, title=\"Dependency Types\")\n\n    else:  # default\n        # Create a layout\n        pos = nx.spring_layout(G, seed=42)\n\n        # Draw the graph\n        nx.draw(G, pos, with_labels=True, node_color=\"lightblue\",\n                node_size=500, edge_color=\"gray\", arrowsize=15, font_size=10)\n\n    plt.title(f\"Intention Dependency Graph: {idg.domain.name}\")\n    plt.axis(\"off\")\n    plt.tight_layout()\n    plt.show()\n\n# Visualize the IDG with different styles\nvisualize_idg_custom(idg, style=\"default\")\nvisualize_idg_custom(idg, style=\"character_colored\")\nvisualize_idg_custom(idg, style=\"dependency_types\")\n</code></pre>"},{"location":"examples/advanced-usage/#integration-with-other-systems","title":"Integration with Other Systems","text":""},{"location":"examples/advanced-usage/#saving-and-loading-domains","title":"Saving and Loading Domains","text":"<p>You can save domains to JSON and load them later:</p> <pre><code>import json\n\ndef save_domain_to_json(domain, filepath):\n    \"\"\"Save a domain to a JSON file.\"\"\"\n    # Convert the domain to a dictionary\n    domain_dict = {\n        \"characters\": domain.characters,\n        \"locations\": domain.locations,\n        \"intentions\": domain.intentions,\n        \"dependencies\": domain.dependencies,\n        \"name\": domain.name,\n        \"description\": domain.description\n    }\n\n    # Write to file\n    with open(filepath, \"w\") as f:\n        json.dump(domain_dict, f, indent=2)\n\n    print(f\"Domain saved to {filepath}\")\n\ndef load_domain_from_json(filepath):\n    \"\"\"Load a domain from a JSON file.\"\"\"\n    # Read from file\n    with open(filepath, \"r\") as f:\n        domain_dict = json.load(f)\n\n    # Create a domain\n    domain = Domain(\n        characters=domain_dict[\"characters\"],\n        locations=domain_dict[\"locations\"],\n        intentions=domain_dict[\"intentions\"],\n        dependencies=domain_dict[\"dependencies\"],\n        name=domain_dict.get(\"name\", \"Loaded Domain\"),\n        description=domain_dict.get(\"description\", \"A domain loaded from JSON.\")\n    )\n\n    print(f\"Domain loaded from {filepath}\")\n    return domain\n\n# Save a domain to JSON\nsave_domain_to_json(domain, \"my_domain.json\")\n\n# Load a domain from JSON\nloaded_domain = load_domain_from_json(\"my_domain.json\")\n</code></pre>"},{"location":"examples/advanced-usage/#web-api-integration","title":"Web API Integration","text":"<p>You can create a simple web API for Narrative:</p> <pre><code>from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route(\"/api/domain\", methods=[\"POST\"])\ndef create_domain():\n    \"\"\"Create a domain from JSON data.\"\"\"\n    data = request.json\n\n    try:\n        domain = Domain(\n            characters=data[\"characters\"],\n            locations=data[\"locations\"],\n            intentions=data[\"intentions\"],\n            dependencies=data[\"dependencies\"],\n            name=data.get(\"name\", \"API Domain\"),\n            description=data.get(\"description\", \"A domain created via API.\")\n        )\n\n        # Build the IDG\n        idg_builder = IDGBuilder(domain)\n        idg = idg_builder.build()\n\n        # Validate the domain\n        errors = idg_builder.validate()\n        if errors:\n            return jsonify({\"status\": \"error\", \"errors\": errors}), 400\n\n        # Return success\n        return jsonify({\"status\": \"success\", \"message\": \"Domain created successfully\"}), 201\n\n    except Exception as e:\n        return jsonify({\"status\": \"error\", \"message\": str(e)}), 400\n\n@app.route(\"/api/trajectory\", methods=[\"POST\"])\ndef generate_trajectory():\n    \"\"\"Generate a trajectory from a domain.\"\"\"\n    data = request.json\n\n    try:\n        # Create the domain\n        domain = Domain(\n            characters=data[\"domain\"][\"characters\"],\n            locations=data[\"domain\"][\"locations\"],\n            intentions=data[\"domain\"][\"intentions\"],\n            dependencies=data[\"domain\"][\"dependencies\"],\n            name=data[\"domain\"].get(\"name\", \"API Domain\"),\n            description=data[\"domain\"].get(\"description\", \"A domain created via API.\")\n        )\n\n        # Build the IDG\n        idg_builder = IDGBuilder(domain)\n        idg = idg_builder.build()\n\n        # Validate the domain\n        errors = idg_builder.validate()\n        if errors:\n            return jsonify({\"status\": \"error\", \"errors\": errors}), 400\n\n        # Generate a trajectory\n        explorer = TrajectoryExplorer(idg)\n        max_length = data.get(\"max_length\", 5)\n        trajectory = explorer.get_random_trajectory(max_length=max_length)\n\n        # Format the trajectory\n        trajectory_data = [\n            {\n                \"id\": intention[\"id\"],\n                \"character\": intention[\"character\"],\n                \"target\": intention[\"target\"],\n                \"location\": intention[\"location\"],\n                \"description\": intention.get(\"description\", \"\")\n            }\n            for intention in trajectory.intentions\n        ]\n\n        # Return the trajectory\n        return jsonify({\n            \"status\": \"success\",\n            \"trajectory\": trajectory_data\n        }), 200\n\n    except Exception as e:\n        return jsonify({\"status\": \"error\", \"message\": str(e)}), 400\n\n@app.route(\"/api/story\", methods=[\"POST\"])\ndef generate_story():\n    \"\"\"Generate a story from a trajectory.\"\"\"\n    data = request.json\n\n    try:\n        # Create the domain\n        domain = Domain(\n            characters=data[\"domain\"][\"characters\"],\n            locations=data[\"domain\"][\"locations\"],\n            intentions=data[\"domain\"][\"intentions\"],\n            dependencies=data[\"domain\"][\"dependencies\"],\n            name=data[\"domain\"].get(\"name\", \"API Domain\"),\n            description=data[\"domain\"].get(\"description\", \"A domain created via API.\")\n        )\n\n        # Build the IDG\n        idg_builder = IDGBuilder(domain)\n        idg = idg_builder.build()\n\n        # Create a trajectory from the provided intentions\n        trajectory = Trajectory(data[\"trajectory\"], domain)\n\n        # Render the story\n        renderer = LLMRenderer()\n        story = renderer.render(trajectory)\n\n        # Return the story\n        return jsonify({\n            \"status\": \"success\",\n            \"story\": story\n        }), 200\n\n    except Exception as e:\n        return jsonify({\"status\": \"error\", \"message\": str(e)}), 400\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre>"},{"location":"examples/advanced-usage/#next-steps","title":"Next Steps","text":"<p>After exploring these advanced techniques, you might want to:</p> <ul> <li>Contribute to the Narrative library by adding new features or improving existing ones</li> <li>Create a custom application that uses Narrative for interactive storytelling</li> <li>Integrate Narrative with other AI systems for more sophisticated narrative generation</li> <li>Explore the API Reference for detailed documentation on all available classes and methods</li> </ul>"},{"location":"examples/custom-domains/","title":"Custom Domains Example","text":"<p>This example demonstrates how to create and use custom domains with Narrative.</p>"},{"location":"examples/custom-domains/#overview","title":"Overview","text":"<p>Custom domains allow you to define your own narrative worlds with unique characters, locations, intentions, and dependencies. This example shows how to:</p> <ol> <li>Define a custom domain</li> <li>Add custom metadata to intentions and dependencies</li> <li>Create custom metrics for trajectory evaluation</li> <li>Visualize and analyze your custom domain</li> </ol>"},{"location":"examples/custom-domains/#creating-a-custom-domain","title":"Creating a Custom Domain","text":"<p>A domain in Narrative represents a narrative world. Here's how to create a custom domain:</p> <pre><code>from narrative.schemas.domain import Domain\n\n# Define a custom domain\ncustom_domain = Domain(\n    characters=[\"character1\", \"character2\", \"character3\"],\n    locations=[\"location1\", \"location2\", \"location3\"],\n    intentions=[\n        {\n            \"id\": \"intention1\",\n            \"character\": \"character1\",\n            \"target\": \"character2\",\n            \"location\": \"location1\",\n            \"description\": \"description of intention1\",\n            \"metadata\": {\n                \"custom_field\": \"custom value\",\n                \"priority\": 1\n            }\n        },\n        {\n            \"id\": \"intention2\",\n            \"character\": \"character2\",\n            \"target\": \"character3\",\n            \"location\": \"location2\",\n            \"description\": \"description of intention2\",\n            \"metadata\": {\n                \"custom_field\": \"another value\",\n                \"priority\": 2\n            }\n        },\n        # Add more intentions as needed\n    ],\n    dependencies=[\n        {\n            \"from_intention\": \"intention2\",\n            \"to_intention\": \"intention1\",\n            \"type\": \"intentional\",\n            \"description\": \"description of dependency\",\n            \"metadata\": {\n                \"strength\": 0.8,\n                \"custom_tag\": \"important\"\n            }\n        },\n        # Add more dependencies as needed\n    ],\n    name=\"Custom Domain Example\",\n    description=\"A custom domain for demonstration purposes.\"\n)\n</code></pre>"},{"location":"examples/custom-domains/#adding-custom-metadata","title":"Adding Custom Metadata","text":"<p>You can add custom metadata to intentions and dependencies to store additional information:</p> <pre><code># Add custom metadata to an intention\nintention = {\n    \"id\": \"custom_intention\",\n    \"character\": \"character1\",\n    \"target\": \"character2\",\n    \"location\": \"location1\",\n    \"description\": \"a custom intention\",\n    \"metadata\": {\n        \"emotional_intensity\": 0.7,\n        \"time_required\": \"2 hours\",\n        \"risk_level\": \"high\",\n        \"tags\": [\"dramatic\", \"pivotal\"]\n    }\n}\n\n# Add custom metadata to a dependency\ndependency = {\n    \"from_intention\": \"intention2\",\n    \"to_intention\": \"intention1\",\n    \"type\": \"motivational\",\n    \"description\": \"a custom dependency\",\n    \"metadata\": {\n        \"strength\": 0.9,\n        \"visibility\": \"hidden\",\n        \"conditions\": [\"condition1\", \"condition2\"],\n        \"probability\": 0.75\n    }\n}\n</code></pre>"},{"location":"examples/custom-domains/#creating-custom-metrics","title":"Creating Custom Metrics","text":"<p>You can create custom metrics to evaluate trajectories according to your own criteria:</p> <pre><code>from narrative.core.trajectory_explorer import MetricProtocol\n\nclass CustomMetric(MetricProtocol):\n    \"\"\"A custom metric for evaluating trajectories.\"\"\"\n\n    def score(self, trajectory):\n        \"\"\"Score a trajectory based on custom criteria.\"\"\"\n        score = 0\n\n        # Example: Score based on the number of unique characters\n        characters = set()\n        for intention in trajectory.intentions:\n            characters.add(intention[\"character\"])\n            if \"target\" in intention and intention[\"target\"] in trajectory.domain.characters:\n                characters.add(intention[\"target\"])\n\n        score += len(characters) / len(trajectory.domain.characters)\n\n        # Example: Score based on the number of unique locations\n        locations = set(intention[\"location\"] for intention in trajectory.intentions)\n        score += len(locations) / len(trajectory.domain.locations)\n\n        # Example: Score based on custom metadata\n        for intention in trajectory.intentions:\n            if \"metadata\" in intention and \"priority\" in intention[\"metadata\"]:\n                score += intention[\"metadata\"][\"priority\"] / 10\n\n        return score / 3  # Normalize to [0, 1]\n\n# Add the custom metric to the explorer\nexplorer.add_metric(\"custom\", CustomMetric())\n\n# Rank trajectories using the custom metric\nranked_trajectories = explorer.rank_trajectories(trajectories, metric=\"custom\")\n</code></pre>"},{"location":"examples/custom-domains/#analyzing-custom-domains","title":"Analyzing Custom Domains","text":"<p>You can analyze your custom domain using the built-in visualization and analysis tools:</p> <pre><code># Build the IDG\nfrom narrative.core.idg_builder import IDGBuilder\n\nidg_builder = IDGBuilder(custom_domain)\nidg = idg_builder.build()\n\n# Validate the domain\nerrors = idg_builder.validate()\nif errors:\n    print(\"Domain validation errors:\")\n    for error in errors:\n        print(f\"- {error}\")\n\n# Visualize the IDG\nidg.visualize()\n\n# Analyze the domain structure\nroot_intentions = idg.get_root_intentions()\nleaf_intentions = idg.get_leaf_intentions()\nprint(f\"Root intentions: {root_intentions}\")\nprint(f\"Leaf intentions: {leaf_intentions}\")\n\n# Analyze intention connectivity\nfor intention_id in custom_domain.get_intention_ids():\n    dependencies = idg.get_dependencies(intention_id)\n    dependents = idg.get_dependents(intention_id)\n    print(f\"Intention {intention_id}:\")\n    print(f\"  Depends on: {dependencies}\")\n    print(f\"  Depended on by: {dependents}\")\n</code></pre>"},{"location":"examples/custom-domains/#complete-example","title":"Complete Example","text":"<p>Here's a complete example of creating and using a custom domain:</p> <pre><code>from narrative.schemas.domain import Domain\nfrom narrative.core.idg_builder import IDGBuilder\nfrom narrative.core.trajectory_explorer import TrajectoryExplorer, MetricProtocol\nfrom narrative.llm.llm_renderer import LLMRenderer\n\n# Define a custom domain\ncustom_domain = Domain(\n    characters=[\"hero\", \"villain\", \"sidekick\"],\n    locations=[\"castle\", \"forest\", \"village\"],\n    intentions=[\n        {\n            \"id\": \"rescue_sidekick\",\n            \"character\": \"hero\",\n            \"target\": \"sidekick\",\n            \"location\": \"castle\",\n            \"description\": \"from the villain's dungeon\",\n            \"metadata\": {\"priority\": 3, \"difficulty\": \"high\"}\n        },\n        {\n            \"id\": \"defeat_villain\",\n            \"character\": \"hero\",\n            \"target\": \"villain\",\n            \"location\": \"castle\",\n            \"description\": \"in an epic battle\",\n            \"metadata\": {\"priority\": 2, \"difficulty\": \"high\"}\n        },\n        {\n            \"id\": \"capture_sidekick\",\n            \"character\": \"villain\",\n            \"target\": \"sidekick\",\n            \"location\": \"forest\",\n            \"description\": \"to lure the hero\",\n            \"metadata\": {\"priority\": 1, \"difficulty\": \"medium\"}\n        },\n        {\n            \"id\": \"prepare_trap\",\n            \"character\": \"villain\",\n            \"target\": \"hero\",\n            \"location\": \"castle\",\n            \"description\": \"to capture the hero\",\n            \"metadata\": {\"priority\": 1, \"difficulty\": \"low\"}\n        },\n        {\n            \"id\": \"escape_forest\",\n            \"character\": \"sidekick\",\n            \"target\": \"sidekick\",\n            \"location\": \"forest\",\n            \"description\": \"to avoid capture\",\n            \"metadata\": {\"priority\": 2, \"difficulty\": \"medium\"}\n        }\n    ],\n    dependencies=[\n        {\n            \"from_intention\": \"defeat_villain\",\n            \"to_intention\": \"rescue_sidekick\",\n            \"type\": \"intentional\",\n            \"description\": \"The hero must defeat the villain to rescue the sidekick\",\n            \"metadata\": {\"strength\": 0.9}\n        },\n        {\n            \"from_intention\": \"rescue_sidekick\",\n            \"to_intention\": \"capture_sidekick\",\n            \"type\": \"motivational\",\n            \"description\": \"The hero wants to rescue the sidekick because the villain captured them\",\n            \"metadata\": {\"strength\": 0.8}\n        },\n        {\n            \"from_intention\": \"prepare_trap\",\n            \"to_intention\": \"capture_sidekick\",\n            \"type\": \"intentional\",\n            \"description\": \"The villain prepares a trap after capturing the sidekick\",\n            \"metadata\": {\"strength\": 0.7}\n        },\n        {\n            \"from_intention\": \"escape_forest\",\n            \"to_intention\": \"capture_sidekick\",\n            \"type\": \"motivational\",\n            \"description\": \"The sidekick tries to escape because the villain is trying to capture them\",\n            \"metadata\": {\"strength\": 0.6}\n        }\n    ],\n    name=\"Hero's Journey\",\n    description=\"A classic hero's journey with a rescue mission.\"\n)\n\n# Define a custom metric\nclass DifficultyMetric(MetricProtocol):\n    \"\"\"A metric that scores trajectories based on difficulty.\"\"\"\n\n    def score(self, trajectory):\n        \"\"\"Score a trajectory based on the difficulty of its intentions.\"\"\"\n        difficulty_map = {\"low\": 0.3, \"medium\": 0.6, \"high\": 1.0}\n        total_difficulty = 0\n\n        for intention in trajectory.intentions:\n            if \"metadata\" in intention and \"difficulty\" in intention[\"metadata\"]:\n                difficulty = intention[\"metadata\"][\"difficulty\"]\n                total_difficulty += difficulty_map.get(difficulty, 0.5)\n\n        # Normalize by the number of intentions\n        return total_difficulty / len(trajectory.intentions) if trajectory.intentions else 0\n\n# Build the IDG\nidg_builder = IDGBuilder(custom_domain)\nidg = idg_builder.build()\n\n# Explore trajectories\nexplorer = TrajectoryExplorer(idg)\nexplorer.add_metric(\"difficulty\", DifficultyMetric())\ntrajectories = explorer.get_trajectories(max_length=5)\n\n# Rank trajectories by difficulty\nranked_by_difficulty = explorer.rank_trajectories(trajectories, metric=\"difficulty\")\n\n# Print the top trajectory\ntop_trajectory = ranked_by_difficulty[0]\nprint(\"\\nMost difficult trajectory:\")\nfor i, intention in enumerate(top_trajectory.intentions):\n    print(\n        f\"{i+1}. {intention['character']} intends to {intention['id']} \"\n        f\"{intention['target']} at {intention['location']}\"\n    )\n\n# Render the story\nrenderer = LLMRenderer()\nstory = renderer.render(top_trajectory)\nprint(\"\\nGenerated Story:\")\nprint(\"=\" * 80)\nprint(story)\nprint(\"=\" * 80)\n</code></pre>"},{"location":"examples/custom-domains/#next-steps","title":"Next Steps","text":"<p>After exploring custom domains, you might want to:</p> <ul> <li>Create more complex domains with larger character and location sets</li> <li>Implement domain-specific metrics for your narrative needs</li> <li>Explore advanced trajectory generation techniques in the Advanced Usage example</li> <li>Learn how to integrate custom domains with other systems</li> </ul>"},{"location":"examples/little-red/","title":"Little Red Riding Hood Example","text":"<p>This example demonstrates how to use Narrative to create a simple narrative based on the Little Red Riding Hood story.</p>"},{"location":"examples/little-red/#overview","title":"Overview","text":"<p>The Little Red Riding Hood example shows how to:</p> <ol> <li>Define a domain with characters, locations, intentions, and dependencies</li> <li>Build an Intention Dependency Graph (IDG)</li> <li>Explore and rank trajectories through the IDG</li> <li>Render a trajectory into a natural language story</li> <li>Visualize the IDG</li> </ol>"},{"location":"examples/little-red/#code-example","title":"Code Example","text":"<pre><code>\"\"\"\nLittle Red Riding Hood Example\n\nThis example demonstrates how to use Narrative to create a simple narrative\nbased on the Little Red Riding Hood story.\n\"\"\"\n\nfrom narrative.core.idg_builder import IDGBuilder\nfrom narrative.core.trajectory_explorer import TrajectoryExplorer\nfrom narrative.llm.llm_renderer import LLMRenderer\nfrom narrative.schemas.domain import Domain\n\n\ndef main() -&gt; None:\n    \"\"\"Run the Little Red Riding Hood example.\"\"\"\n    # Define the domain\n    domain = Domain(\n        characters=[\"little_red\", \"wolf\", \"grandmother\", \"hunter\"],\n        locations=[\"forest\", \"cottage\", \"village\"],\n        intentions=[\n            {\n                \"id\": \"visit_grandmother\",\n                \"character\": \"little_red\",\n                \"target\": \"grandmother\",\n                \"location\": \"cottage\",\n                \"description\": \"to check on her health\",\n            },\n            {\n                \"id\": \"deliver_basket\",\n                \"character\": \"little_red\",\n                \"target\": \"grandmother\",\n                \"location\": \"cottage\",\n                \"description\": \"containing food and medicine\",\n            },\n            {\n                \"id\": \"eat_little_red\",\n                \"character\": \"wolf\",\n                \"target\": \"little_red\",\n                \"location\": \"forest\",\n                \"description\": \"after tricking her\",\n            },\n            {\n                \"id\": \"eat_grandmother\",\n                \"character\": \"wolf\",\n                \"target\": \"grandmother\",\n                \"location\": \"cottage\",\n                \"description\": \"after disguising as Little Red\",\n            },\n            {\n                \"id\": \"rescue_little_red\",\n                \"character\": \"hunter\",\n                \"target\": \"little_red\",\n                \"location\": \"cottage\",\n                \"description\": \"from the wolf's stomach\",\n            },\n            {\n                \"id\": \"rescue_grandmother\",\n                \"character\": \"hunter\",\n                \"target\": \"grandmother\",\n                \"location\": \"cottage\",\n                \"description\": \"from the wolf's stomach\",\n            },\n            {\n                \"id\": \"kill_wolf\",\n                \"character\": \"hunter\",\n                \"target\": \"wolf\",\n                \"location\": \"cottage\",\n                \"description\": \"to save Little Red and Grandmother\",\n            },\n        ],\n        dependencies=[\n            {\n                \"from_intention\": \"deliver_basket\",\n                \"to_intention\": \"visit_grandmother\",\n                \"type\": \"intentional\",\n                \"description\": (\n                    \"Little Red must visit Grandmother to deliver the basket\"\n                ),\n            },\n            {\n                \"from_intention\": \"eat_little_red\",\n                \"to_intention\": \"visit_grandmother\",\n                \"type\": \"motivational\",\n                \"description\": (\n                    \"The Wolf wants to eat Little Red because she is visiting\"\n                    \" Grandmother\"\n                ),\n            },\n            {\n                \"from_intention\": \"eat_grandmother\",\n                \"to_intention\": \"visit_grandmother\",\n                \"type\": \"motivational\",\n                \"description\": (\n                    \"The Wolf wants to eat Grandmother because Little Red is\"\n                    \" visiting her\"\n                ),\n            },\n            {\n                \"from_intention\": \"rescue_little_red\",\n                \"to_intention\": \"eat_little_red\",\n                \"type\": \"motivational\",\n                \"description\": (\n                    \"The Hunter wants to rescue Little Red because the Wolf ate her\"\n                ),\n            },\n            {\n                \"from_intention\": \"rescue_grandmother\",\n                \"to_intention\": \"eat_grandmother\",\n                \"type\": \"motivational\",\n                \"description\": (\n                    \"The Hunter wants to rescue Grandmother because the Wolf ate her\"\n                ),\n            },\n            {\n                \"from_intention\": \"kill_wolf\",\n                \"to_intention\": \"eat_little_red\",\n                \"type\": \"motivational\",\n                \"description\": (\n                    \"The Hunter wants to kill the Wolf because it ate Little Red\"\n                ),\n            },\n            {\n                \"from_intention\": \"kill_wolf\",\n                \"to_intention\": \"eat_grandmother\",\n                \"type\": \"motivational\",\n                \"description\": (\n                    \"The Hunter wants to kill the Wolf because it ate Grandmother\"\n                ),\n            },\n        ],\n        name=\"Little Red Riding Hood\",\n        description=(\n            \"A classic fairy tale about a little girl, her grandmother, and a wolf.\"\n        ),\n    )\n\n    # Build the IDG\n    print(\"Building the Intention Dependency Graph (IDG)...\")\n    idg_builder = IDGBuilder(domain)\n    idg = idg_builder.build()\n\n    # Validate the domain\n    errors = idg_builder.validate()\n    if errors:\n        print(\"Domain validation errors:\")\n        for error in errors:\n            print(f\"- {error}\")\n        return\n\n    # Explore trajectories\n    print(\"Exploring trajectories...\")\n    explorer = TrajectoryExplorer(idg)\n    trajectories = explorer.get_trajectories(max_length=7)\n    print(f\"Found {len(trajectories)} trajectories.\")\n\n    # Rank trajectories\n    print(\"Ranking trajectories by drama...\")\n    ranked_trajectories = explorer.rank_trajectories(trajectories, metric=\"drama\")\n\n    # Print the top trajectory\n    top_trajectory = ranked_trajectories[0]\n    print(\"\\nTop trajectory:\")\n    for i, intention in enumerate(top_trajectory.intentions):\n        print(\n            f\"{i+1}. {intention['character']} intends to {intention['id']} \"\n            f\"{intention['target']} at {intention['location']}\"\n        )\n\n    # Render the story\n    print(\"\\nRendering the story...\")\n    renderer = LLMRenderer()  # Uses a mock LLM by default\n    story = renderer.render(top_trajectory)\n\n    # Print the story\n    print(\"\\nGenerated Story:\")\n    print(\"=\" * 80)\n    print(story)\n    print(\"=\" * 80)\n\n    # Visualize the IDG (requires matplotlib)\n    try:\n        print(\"\\nVisualizing the IDG...\")\n        idg.visualize()\n    except ImportError:\n        print(\n            \"\\nMatplotlib is required for visualization. Install it with 'pip install\"\n            \" matplotlib'.\"\n        )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/little-red/#running-the-example","title":"Running the Example","text":"<p>You can run this example with:</p> <pre><code>python -m narrative.examples.little_red\n</code></pre>"},{"location":"examples/little-red/#expected-output","title":"Expected Output","text":"<p>When you run the example, you should see:</p> <ol> <li>The domain being built and validated</li> <li>Trajectories being explored and ranked</li> <li>The top trajectory being printed</li> <li>A generated story based on the top trajectory</li> <li>A visualization of the IDG (if matplotlib is installed)</li> </ol>"},{"location":"examples/little-red/#next-steps","title":"Next Steps","text":"<p>After exploring this example, you might want to:</p> <ul> <li>Try modifying the domain to create your own narrative</li> <li>Experiment with different metrics for ranking trajectories</li> <li>Create a custom LLM adapter for more sophisticated story generation</li> <li>Check out the Custom Domains and Advanced Usage examples</li> </ul>"},{"location":"guides/concepts/","title":"Core Concepts","text":"<p>This guide explains the core concepts behind Narrative and how they work together to create compelling narratives.</p>"},{"location":"guides/concepts/#overview","title":"Overview","text":"<p>Narrative is built around several key concepts that were introduced in the AAAI paper on Intention Dependency Graphs:</p> <ol> <li>Domains: The narrative world, including characters, locations, and intentions</li> <li>Intentions: Goals or desires that characters have</li> <li>Dependencies: Relationships between intentions</li> <li>Intention Dependency Graphs (IDGs): A graph representation of intentions and their dependencies</li> <li>Trajectories: Paths through an IDG that form coherent narratives</li> <li>Metrics: Ways to evaluate and rank trajectories</li> <li>Rendering: Converting trajectories into natural language stories using LLMs</li> </ol> <p>Let's explore each of these concepts in more detail.</p>"},{"location":"guides/concepts/#domains","title":"Domains","text":"<p>A domain represents a narrative world with characters, locations, intentions, and dependencies. It's the foundation of any narrative created with NarrativeIDG.</p> <pre><code>from narrative import Domain\n\ndomain = Domain(\n    characters=[\"little_red\", \"wolf\", \"grandmother\", \"hunter\"],\n    locations=[\"forest\", \"cottage\", \"village\"],\n    intentions=[...],\n    dependencies=[...],\n    name=\"Little Red Riding Hood\",\n    description=\"A classic fairy tale about a little girl, her grandmother, and a wolf.\"\n)\n</code></pre> <p>A domain must have at least one character, one location, and one intention. Dependencies are optional but are usually necessary to create interesting narratives.</p>"},{"location":"guides/concepts/#intentions","title":"Intentions","text":"<p>An intention represents a character's goal or desire. It's defined by:</p> <ul> <li>An ID (a unique identifier)</li> <li>A character (who has the intention)</li> <li>A target (usually another character)</li> <li>A location (where the intention takes place)</li> <li>An optional description</li> <li>Optional metadata</li> </ul> <pre><code>{\n    \"id\": \"visit_grandmother\",\n    \"character\": \"little_red\",\n    \"target\": \"grandmother\",\n    \"location\": \"cottage\",\n    \"description\": \"to check on her health\"\n}\n</code></pre> <p>Intentions are the building blocks of narratives. They represent what characters want to do and why they want to do it.</p>"},{"location":"guides/concepts/#dependencies","title":"Dependencies","text":"<p>A dependency represents a relationship between two intentions. It's defined by:</p> <ul> <li>A from_intention (the intention that depends on another)</li> <li>A to_intention (the intention that is depended upon)</li> <li>A type (intentional or motivational)</li> <li>An optional description</li> <li>Optional metadata</li> </ul> <pre><code>{\n    \"from_intention\": \"deliver_basket\",\n    \"to_intention\": \"visit_grandmother\",\n    \"type\": \"intentional\",\n    \"description\": \"Little Red must visit Grandmother to deliver the basket\"\n}\n</code></pre> <p>There are two types of dependencies:</p> <ul> <li>Intentional: The from_intention is a sub-goal of the to_intention. For example, \"deliver_basket\" is a sub-goal of \"visit_grandmother\".</li> <li>Motivational: The from_intention is motivated by the to_intention. For example, \"eat_little_red\" is motivated by \"visit_grandmother\" (the wolf wants to eat Little Red because she is visiting her grandmother).</li> </ul>"},{"location":"guides/concepts/#intention-dependency-graphs-idgs","title":"Intention Dependency Graphs (IDGs)","text":"<p>An Intention Dependency Graph (IDG) is a directed graph where nodes represent intentions and edges represent dependencies between intentions. This concept was introduced in the original research paper as a way to model narrative structures. IDGs are built from a domain using the IDGBuilder class.</p> <pre><code>from narrative import IDGBuilder\n\nidg_builder = IDGBuilder(domain)\nidg = idg_builder.build()\n</code></pre> <p>The IDG provides methods for working with the graph, such as:</p> <ul> <li><code>get_root_intentions()</code>: Get intentions that are not depended upon by any other intention</li> <li><code>get_leaf_intentions()</code>: Get intentions that do not depend on any other intention</li> <li><code>get_intention_data(intention_id)</code>: Get the data associated with an intention</li> <li><code>get_dependency_data(from_intention, to_intention)</code>: Get the data associated with a dependency</li> <li><code>visualize()</code>: Visualize the IDG using matplotlib</li> </ul>"},{"location":"guides/concepts/#trajectories","title":"Trajectories","text":"<p>A trajectory is a path through an IDG that forms a coherent narrative. It's a sequence of intentions that can be rendered into a natural language story.</p> <p>Trajectories are generated using the TrajectoryExplorer class:</p> <pre><code>from narrative import TrajectoryExplorer\n\nexplorer = TrajectoryExplorer(idg)\ntrajectories = explorer.get_trajectories(max_length=5)\n</code></pre> <p>The <code>get_trajectories()</code> method generates all possible trajectories through the IDG up to a maximum length. You can also generate a random trajectory using the <code>get_random_trajectory()</code> method.</p>"},{"location":"guides/concepts/#metrics","title":"Metrics","text":"<p>Metrics are used to evaluate and rank trajectories according to different criteria. Narrative includes several built-in metrics:</p> <ul> <li>Novelty: Measures the diversity of characters, locations, and intention types</li> <li>Coherence: Measures the continuity of characters and locations between adjacent intentions</li> <li>Drama: Measures the presence of conflict, character arcs, and emotional intensity</li> </ul> <p>You can rank trajectories using these metrics:</p> <pre><code>ranked_trajectories = explorer.rank_trajectories(trajectories, metric=\"drama\")\n</code></pre> <p>You can also create custom metrics by implementing a class with a <code>score()</code> method:</p> <pre><code>class LengthMetric:\n    def score(self, trajectory):\n        return len(trajectory.intentions)\n\nexplorer.add_metric(\"length\", LengthMetric())\nranked_by_length = explorer.rank_trajectories(trajectories, metric=\"length\")\n</code></pre>"},{"location":"guides/concepts/#rendering","title":"Rendering","text":"<p>Rendering is the process of converting a trajectory into a natural language story using a large language model (LLM). NarrativeIDG includes the LLMRenderer class for this purpose:</p> <pre><code>from narrative import LLMRenderer\n\nrenderer = LLMRenderer()\nstory = renderer.render(trajectory)\n</code></pre> <p>By default, the LLMRenderer uses a mock LLM that returns a predefined story. You can use a real LLM by creating a custom adapter:</p> <pre><code>from narrative.llm.llm_renderer import OpenAIAdapter\n\nadapter = OpenAIAdapter(api_key=\"your-api-key-here\")\nrenderer = LLMRenderer(adapter=adapter)\n</code></pre> <p>You can also create your own adapter by implementing the LLMAdapter interface:</p> <pre><code>from narrative.llm.llm_renderer import LLMAdapter\n\nclass MyAdapter(LLMAdapter):\n    def generate(self, prompt):\n        # Your implementation here\n        return \"Generated story\"\n\nrenderer = LLMRenderer(adapter=MyAdapter())\n</code></pre>"},{"location":"guides/concepts/#putting-it-all-together","title":"Putting It All Together","text":"<p>Here's how these concepts work together to create a narrative:</p> <ol> <li>You define a domain with characters, locations, intentions, and dependencies.</li> <li>The IDGBuilder builds an IDG from the domain.</li> <li>The TrajectoryExplorer generates trajectories through the IDG.</li> <li>You rank the trajectories using metrics to find the most interesting ones.</li> <li>The LLMRenderer renders a trajectory into a natural language story.</li> </ol> <p>This process combines symbolic planning (the IDG and trajectories) with natural language generation (the LLM) to create compelling narratives that are both coherent and engaging.</p>"},{"location":"guides/concepts/#next-steps","title":"Next Steps","text":"<p>Now that you understand the core concepts of Narrative, you can:</p> <ul> <li>Follow the Quick Start Guide to create your first narrative</li> <li>Explore the API Reference for detailed documentation</li> <li>Check out more examples in the Examples section</li> </ul>"},{"location":"guides/concepts/#further-reading","title":"Further Reading","text":"<p>For a deeper understanding of the theoretical foundations of Narrative, we recommend reading the original research paper:</p> <ul> <li>Intention Dependency Graphs for Interactive Narrative Generation - This paper introduces the concept of Intention Dependency Graphs (IDGs) and explains how they can be used to generate coherent and engaging narratives.</li> </ul>"},{"location":"guides/documentation/","title":"Documentation Guide","text":"<p>This guide explains how to generate documentation using MkDocs and how to use the GitHub CI workflow for automatic documentation deployment.</p>"},{"location":"guides/documentation/#setting-up-mkdocs-locally","title":"Setting Up MkDocs Locally","text":""},{"location":"guides/documentation/#prerequisites","title":"Prerequisites","text":"<p>Before you can generate documentation, make sure you have:</p> <ol> <li>Python 3.12 or later installed</li> <li>Poetry installed (see Installation Guide)</li> <li>The project cloned to your local machine</li> </ol>"},{"location":"guides/documentation/#installing-documentation-dependencies","title":"Installing Documentation Dependencies","text":"<p>The documentation dependencies are defined in the <code>pyproject.toml</code> file under the <code>[tool.poetry.group.docs.dependencies]</code> section. To install them, run:</p> <pre><code>poetry install --with docs\n</code></pre> <p>This will install MkDocs, the Material theme, and other plugins required for building the documentation.</p>"},{"location":"guides/documentation/#building-documentation-locally","title":"Building Documentation Locally","text":"<p>To build the documentation locally, run:</p> <pre><code>poetry run mkdocs build\n</code></pre> <p>This will generate the static site in the <code>site</code> directory. You can open the <code>site/index.html</code> file in your browser to view the documentation.</p>"},{"location":"guides/documentation/#serving-documentation-locally","title":"Serving Documentation Locally","text":"<p>For development purposes, you can serve the documentation locally with live reloading:</p> <pre><code>poetry run mkdocs serve\n</code></pre> <p>This will start a local server at http://127.0.0.1:8000/ where you can preview the documentation as you make changes.</p>"},{"location":"guides/documentation/#documentation-structure","title":"Documentation Structure","text":"<p>The documentation is organized as follows:</p> <ul> <li><code>docs/</code>: Contains all the documentation source files</li> <li><code>index.md</code>: The home page</li> <li><code>guides/</code>: User guides and tutorials</li> <li><code>api/</code>: API reference documentation</li> <li><code>examples/</code>: Example usage and code snippets</li> </ul> <p>The navigation structure is defined in the <code>mkdocs.yml</code> file under the <code>nav</code> section.</p>"},{"location":"guides/documentation/#adding-new-documentation","title":"Adding New Documentation","text":"<p>To add new documentation:</p> <ol> <li>Create a new Markdown file in the appropriate directory</li> <li>Add the file to the navigation structure in <code>mkdocs.yml</code></li> <li>Build and preview the documentation locally</li> <li>Commit and push your changes</li> </ol>"},{"location":"guides/documentation/#using-the-github-ci-workflow","title":"Using the GitHub CI Workflow","text":"<p>The project includes a GitHub CI workflow that automatically builds and deploys the documentation when changes are pushed to the main branch.</p>"},{"location":"guides/documentation/#how-the-ci-workflow-works","title":"How the CI Workflow Works","text":"<p>The workflow is defined in <code>.github/workflows/docs-build.yml</code> and consists of two jobs:</p> <ol> <li><code>build</code>: Builds the documentation and uploads it as an artifact</li> <li><code>deploy</code>: Deploys the documentation to GitHub Pages (only on the main branch)</li> </ol> <p>The workflow is triggered when: - Changes are pushed to the main branch that affect documentation files - A pull request is opened or updated that affects documentation files - The workflow is manually triggered</p>"},{"location":"guides/documentation/#setting-up-github-pages-for-the-first-time","title":"Setting Up GitHub Pages for the First Time","text":"<p>To set up GitHub Pages for your documentation:</p> <ol> <li>Go to your repository on GitHub</li> <li>Navigate to Settings &gt; Pages</li> <li>Under \"Source\", select \"GitHub Actions\"</li> <li>Make sure your repository has the appropriate permissions for GitHub Actions</li> </ol>"},{"location":"guides/documentation/#manually-triggering-the-workflow","title":"Manually Triggering the Workflow","text":"<p>You can manually trigger the documentation build and deploy workflow:</p> <ol> <li>Go to your repository on GitHub</li> <li>Navigate to Actions &gt; Build and Deploy Documentation</li> <li>Click \"Run workflow\"</li> <li>Select the branch to run the workflow on</li> <li>Click \"Run workflow\"</li> </ol>"},{"location":"guides/documentation/#troubleshooting-ci-issues","title":"Troubleshooting CI Issues","text":"<p>If the CI workflow fails, check the following:</p> <ol> <li>Make sure all documentation dependencies are correctly specified in <code>pyproject.toml</code></li> <li>Verify that the documentation builds successfully locally</li> <li>Check the workflow logs for specific error messages</li> <li>Ensure that the repository has the necessary permissions for GitHub Actions</li> </ol>"},{"location":"guides/documentation/#best-practices-for-documentation","title":"Best Practices for Documentation","text":"<ul> <li>Keep documentation up-to-date with code changes</li> <li>Use clear, concise language</li> <li>Include code examples where appropriate</li> <li>Use admonitions (notes, warnings, tips) to highlight important information</li> <li>Add diagrams or images to explain complex concepts</li> <li>Test documentation locally before pushing changes</li> <li>Review documentation in pull requests</li> </ul>"},{"location":"guides/documentation/#generating-api-reference-documentation","title":"Generating API Reference Documentation","text":"<p>The API reference documentation is generated automatically from docstrings using the <code>mkdocstrings</code> plugin. To ensure your API is well-documented:</p> <ol> <li>Write comprehensive docstrings for all public classes, methods, and functions</li> <li>Use Google-style docstrings, as configured in <code>mkdocs.yml</code></li> <li>Include type hints in your code</li> <li>Run <code>poetry run mkdocs build --strict</code> to check for documentation errors</li> </ol>"},{"location":"guides/installation/","title":"Installation Guide","text":"<p>This guide will help you install Narrative and its dependencies.</p>"},{"location":"guides/installation/#requirements","title":"Requirements","text":"<p>Narrative requires:</p> <ul> <li>Python 3.12 or higher</li> <li>NetworkX 3.2 or higher</li> <li>Pydantic 2.5 or higher</li> </ul>"},{"location":"guides/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"guides/installation/#using-pip","title":"Using pip","text":"<p>The simplest way to install Narrative is using pip:</p> <pre><code>pip install narrative\n</code></pre>"},{"location":"guides/installation/#using-poetry","title":"Using Poetry","text":"<p>If you use Poetry for dependency management, you can add Narrative to your project:</p> <pre><code>poetry add narrative\n</code></pre>"},{"location":"guides/installation/#from-source","title":"From Source","text":"<p>To install from source:</p> <ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/org/narrative.git\ncd narrative\n</code></pre> <ol> <li>Install using Poetry:</li> </ol> <pre><code>poetry install\n</code></pre> <p>Or using pip:</p> <pre><code>pip install .\n</code></pre>"},{"location":"guides/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>Narrative has several optional dependencies for additional features:</p>"},{"location":"guides/installation/#visualization","title":"Visualization","text":"<p>For visualization features (e.g., <code>IDG.visualize()</code>), install matplotlib:</p> <pre><code>pip install narrative[visualization]\n</code></pre> <p>Or with Poetry:</p> <pre><code>poetry add narrative -E visualization\n</code></pre>"},{"location":"guides/installation/#openai-integration","title":"OpenAI Integration","text":"<p>To use the OpenAI adapter for LLM rendering:</p> <pre><code>pip install narrative[openai]\n</code></pre> <p>Or with Poetry:</p> <pre><code>poetry add narrative -E openai\n</code></pre>"},{"location":"guides/installation/#all-optional-dependencies","title":"All Optional Dependencies","text":"<p>To install all optional dependencies:</p> <pre><code>pip install narrative[all]\n</code></pre> <p>Or with Poetry:</p> <pre><code>poetry add narrative -E all\n</code></pre>"},{"location":"guides/installation/#development-installation","title":"Development Installation","text":"<p>For development, you'll want to install the development dependencies:</p> <pre><code>git clone https://github.com/org/narrative.git\ncd narrative\npoetry install --with dev,docs\n</code></pre> <p>This will install all the dependencies needed for development, testing, and building the documentation.</p>"},{"location":"guides/installation/#verifying-installation","title":"Verifying Installation","text":"<p>To verify that Narrative is installed correctly, run:</p> <pre><code>import narrative\nprint(narrative.__version__)\n</code></pre> <p>This should print the version number of Narrative.</p>"},{"location":"guides/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/installation/#importerror-no-module-named-narrative","title":"ImportError: No module named 'narrative'","text":"<p>This error occurs when Python cannot find the Narrative package. Make sure you have installed it correctly and that you're using the same Python environment where you installed it.</p>"},{"location":"guides/installation/#importerror-no-module-named-matplotlib","title":"ImportError: No module named 'matplotlib'","text":"<p>This error occurs when trying to use visualization features without having matplotlib installed. Install the visualization dependencies as described above.</p>"},{"location":"guides/installation/#importerror-no-module-named-openai","title":"ImportError: No module named 'openai'","text":"<p>This error occurs when trying to use the OpenAI adapter without having the OpenAI package installed. Install the OpenAI dependencies as described above.</p>"},{"location":"guides/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have Narrative installed, check out the Quick Start Guide to learn how to use it.</p>"},{"location":"guides/quick-start/","title":"Quick Start Guide","text":"<p>This guide will help you get started with Narrative by walking through a simple example.</p>"},{"location":"guides/quick-start/#installation","title":"Installation","text":"<p>First, make sure you have Narrative installed:</p> <pre><code>pip install narrative\n</code></pre> <p>For more installation options, see the Installation Guide.</p>"},{"location":"guides/quick-start/#basic-usage","title":"Basic Usage","text":"<p>Let's create a simple narrative based on the Little Red Riding Hood story.</p>"},{"location":"guides/quick-start/#1-define-the-domain","title":"1. Define the Domain","text":"<p>First, we need to define the narrative domain with characters, locations, intentions, and dependencies:</p> <pre><code>from narrative import Domain, IDGBuilder, TrajectoryExplorer, LLMRenderer\n\n# Define the domain\ndomain = Domain(\n    characters=[\"little_red\", \"wolf\", \"grandmother\", \"hunter\"],\n    locations=[\"forest\", \"cottage\", \"village\"],\n    intentions=[\n        {\n            \"id\": \"visit_grandmother\",\n            \"character\": \"little_red\",\n            \"target\": \"grandmother\",\n            \"location\": \"cottage\",\n            \"description\": \"to check on her health\",\n        },\n        {\n            \"id\": \"deliver_basket\",\n            \"character\": \"little_red\",\n            \"target\": \"grandmother\",\n            \"location\": \"cottage\",\n            \"description\": \"containing food and medicine\",\n        },\n        {\n            \"id\": \"eat_little_red\",\n            \"character\": \"wolf\",\n            \"target\": \"little_red\",\n            \"location\": \"forest\",\n            \"description\": \"after tricking her\",\n        },\n        {\n            \"id\": \"eat_grandmother\",\n            \"character\": \"wolf\",\n            \"target\": \"grandmother\",\n            \"location\": \"cottage\",\n            \"description\": \"after disguising as Little Red\",\n        },\n        {\n            \"id\": \"rescue_little_red\",\n            \"character\": \"hunter\",\n            \"target\": \"little_red\",\n            \"location\": \"cottage\",\n            \"description\": \"from the wolf's stomach\",\n        },\n        {\n            \"id\": \"rescue_grandmother\",\n            \"character\": \"hunter\",\n            \"target\": \"grandmother\",\n            \"location\": \"cottage\",\n            \"description\": \"from the wolf's stomach\",\n        },\n        {\n            \"id\": \"kill_wolf\",\n            \"character\": \"hunter\",\n            \"target\": \"wolf\",\n            \"location\": \"cottage\",\n            \"description\": \"to save Little Red and Grandmother\",\n        },\n    ],\n    dependencies=[\n        {\n            \"from_intention\": \"deliver_basket\",\n            \"to_intention\": \"visit_grandmother\",\n            \"type\": \"intentional\",\n            \"description\": \"Little Red must visit Grandmother to deliver the basket\",\n        },\n        {\n            \"from_intention\": \"eat_little_red\",\n            \"to_intention\": \"visit_grandmother\",\n            \"type\": \"motivational\",\n            \"description\": \"The Wolf wants to eat Little Red because she is visiting Grandmother\",\n        },\n        {\n            \"from_intention\": \"eat_grandmother\",\n            \"to_intention\": \"visit_grandmother\",\n            \"type\": \"motivational\",\n            \"description\": \"The Wolf wants to eat Grandmother because Little Red is visiting her\",\n        },\n        {\n            \"from_intention\": \"rescue_little_red\",\n            \"to_intention\": \"eat_little_red\",\n            \"type\": \"motivational\",\n            \"description\": \"The Hunter wants to rescue Little Red because the Wolf ate her\",\n        },\n        {\n            \"from_intention\": \"rescue_grandmother\",\n            \"to_intention\": \"eat_grandmother\",\n            \"type\": \"motivational\",\n            \"description\": \"The Hunter wants to rescue Grandmother because the Wolf ate her\",\n        },\n        {\n            \"from_intention\": \"kill_wolf\",\n            \"to_intention\": \"eat_little_red\",\n            \"type\": \"motivational\",\n            \"description\": \"The Hunter wants to kill the Wolf because it ate Little Red\",\n        },\n        {\n            \"from_intention\": \"kill_wolf\",\n            \"to_intention\": \"eat_grandmother\",\n            \"type\": \"motivational\",\n            \"description\": \"The Hunter wants to kill the Wolf because it ate Grandmother\",\n        },\n    ],\n    name=\"Little Red Riding Hood\",\n    description=\"A classic fairy tale about a little girl, her grandmother, and a wolf.\",\n)\n</code></pre>"},{"location":"guides/quick-start/#2-build-the-intention-dependency-graph-idg","title":"2. Build the Intention Dependency Graph (IDG)","text":"<p>Next, we build an IDG from the domain:</p> <pre><code># Build the IDG\nidg_builder = IDGBuilder(domain)\nidg = idg_builder.build()\n\n# Validate the domain\nerrors = idg_builder.validate()\nif errors:\n    print(\"Domain validation errors:\")\n    for error in errors:\n        print(f\"- {error}\")\n</code></pre>"},{"location":"guides/quick-start/#3-explore-trajectories","title":"3. Explore Trajectories","text":"<p>Now we can explore possible trajectories through the IDG:</p> <pre><code># Create a trajectory explorer\nexplorer = TrajectoryExplorer(idg)\n\n# Generate all possible trajectories up to length 7\ntrajectories = explorer.get_trajectories(max_length=7)\nprint(f\"Found {len(trajectories)} trajectories.\")\n\n# Rank trajectories by drama\nranked_trajectories = explorer.rank_trajectories(trajectories, metric=\"drama\")\n\n# Print the top trajectory\ntop_trajectory = ranked_trajectories[0]\nprint(\"\\nTop trajectory:\")\nfor i, intention in enumerate(top_trajectory.intentions):\n    print(\n        f\"{i+1}. {intention['character']} intends to {intention['id']} \"\n        f\"{intention['target']} at {intention['location']}\"\n    )\n</code></pre>"},{"location":"guides/quick-start/#4-render-a-story","title":"4. Render a Story","text":"<p>Finally, we can render the trajectory into a natural language story:</p> <pre><code># Create a renderer (uses a mock LLM by default)\nrenderer = LLMRenderer()\n\n# Render the story\nstory = renderer.render(top_trajectory)\nprint(\"\\nGenerated Story:\")\nprint(\"=\" * 80)\nprint(story)\nprint(\"=\" * 80)\n</code></pre>"},{"location":"guides/quick-start/#5-visualize-the-idg","title":"5. Visualize the IDG","text":"<p>If you have matplotlib installed, you can visualize the IDG:</p> <pre><code># Visualize the IDG\nidg.visualize()\n</code></pre>"},{"location":"guides/quick-start/#using-a-custom-llm","title":"Using a Custom LLM","text":"<p>By default, Narrative uses a mock LLM that returns a predefined story. To use a real LLM like OpenAI's GPT models, you can create a custom adapter:</p> <pre><code>from narrative.llm.llm_renderer import OpenAIAdapter\n\n# Create an OpenAI adapter\nadapter = OpenAIAdapter(api_key=\"your-api-key-here\")\n\n# Create a renderer with the custom adapter\nrenderer = LLMRenderer(adapter=adapter)\n\n# Render the story\nstory = renderer.render(top_trajectory)\n</code></pre>"},{"location":"guides/quick-start/#creating-custom-metrics","title":"Creating Custom Metrics","text":"<p>You can create custom metrics to rank trajectories according to your own criteria:</p> <pre><code>class LengthMetric:\n    \"\"\"A metric that scores trajectories based on length.\"\"\"\n\n    def score(self, trajectory):\n        \"\"\"Score a trajectory based on length.\"\"\"\n        return len(trajectory.intentions)\n\n# Add the custom metric to the explorer\nexplorer.add_metric(\"length\", LengthMetric())\n\n# Rank trajectories by length\nranked_by_length = explorer.rank_trajectories(trajectories, metric=\"length\")\n</code></pre>"},{"location":"guides/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you've seen the basics of Narrative, you can:</p> <ul> <li>Learn more about the core concepts in the Concepts Guide</li> <li>Explore the API Reference for detailed documentation</li> <li>Check out more examples in the Examples section</li> <li>Learn how to generate documentation and use GitHub CI for contributing to the project</li> </ul>"}]}